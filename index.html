<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Lockscreen</title>
    <!-- MODIFIED: Favicons for Car Dash / Browser Tabs -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='20' fill='%232c2c2e'/%3E%3Ccircle cx='50' cy='50' r='30' fill='none' stroke='white' stroke-width='8'/%3E%3C/svg%3E">
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='20' fill='%232c2c2e'/%3E%3Ccircle cx='50' cy='50' r='30' fill='none' stroke='white' stroke-width='8'/%3E%3C/svg%3E">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Oswald:wght@700&family=Roboto+Mono:wght@500&family=Roboto:wght@400;500&family=Playfair+Display:wght@700&family=Source+Code+Pro:wght@700&family=Inter:wght@400;500&family=Lora:wght@400;500&display=swap');
        :root {
            --widget-bg: rgba(0, 0, 0, 0.2);
            --widget-bg-light: rgba(255, 255, 255, 0.2);
            --text-color: white;
            --text-color-light: #333;
            --text-shadow: 1px 1px 3px rgba(0,0,0,0.6);
            --text-shadow-light: 1px 1px 3px rgba(255,255,255,0.4);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; width: 100%; overflow: hidden; font-family: 'Roboto', sans-serif; }
        body { background-color: #1a1a1a; color: white; text-align: center; }
        #lock-screen { position: relative; width: 100vw; height: 100vh; background-image: url('https://images.pexels.com/photos/807598/pexels-photo-807598.jpeg'); background-size: cover; background-position: center center; overflow: hidden; transition: background-image 0.5s ease-in-out; text-align: left; --icon-stroke-color: white; }
        #lock-screen.panning-active { cursor: grab; border: 2px solid rgba(10, 132, 255, 0.6); box-shadow: inset 0 0 20px rgba(10, 132, 255, 0.3); } #lock-screen.panning-active:active { cursor: grabbing; }
        #status-bar { position: absolute; top: 20px; right: 30px; font-size: 1rem; text-shadow: var(--text-shadow); z-index: 20; color: var(--text-color); }
        #weather-info { display: flex; align-items: center; gap: 10px; user-select: none; padding: 10px 15px; border-radius: 12px; transition: background-color 0.2s; background-color: var(--widget-bg); }
        .draggable-item { position: absolute; user-select: none; cursor: grab; z-index: 10; } .draggable-item:active { cursor: grabbing; z-index: 11; }
        #clock { top: 30%; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; justify-content: center; font-family: 'Oswald', sans-serif; font-weight: 700; color: #fff; filter: drop-shadow(0 0 20px rgba(0,0,0,0.5)); }
        #hours, #minutes { font-size: clamp(6rem, 15vw, 12rem); line-height: 0.8; pointer-events: none; } #minutes { margin-top: -1.5rem; }
        .app-icon { width: 70px; height: 70px; filter: drop-shadow(0 4px 8px rgba(0,0,0,0.4)); transition: transform 0.2s ease; } .app-icon:active { transform: scale(1.1); }
        .app-icon svg { width: 100%; height: 100%; }
        #youtube-music-btn { top: 60%; left: calc(50% - 100px); } #youtube-btn { top: 60%; left: calc(50% + 30px); }
        .widget { background-color: var(--widget-bg); padding: 10px 15px; border-radius: 12px; color: var(--text-color); font-family: 'Roboto', sans-serif; text-shadow: var(--text-shadow); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); }
        #stock-widget { top: 75%; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; gap: 8px; min-width: 190px; }
        .stock-row { display: flex; justify-content: space-between; align-items: center; }
        .stock-info { display: flex; align-items: center; gap: 10px; font-weight: 500; letter-spacing: 0.5px;}
        .stock-price { font-family: 'Roboto Mono', monospace; font-weight: 500; font-size: 1.1rem; }
        .stock-info .fa-caret-up { color: #2ecc71; } .stock-info .fa-caret-down { color: #e74c3c; }
        
        #note-widget { top: 60%; left: 75%; width: 250px; height: 180px; padding: 0; resize: both; overflow: hidden; transition: box-shadow 0.3s; }
        #note-widget.edit-mode { cursor: default; box-shadow: 0 0 15px rgba(10, 132, 255, 0.7); }
        #note-display, #note-textarea { width: 100%; height: 100%; background: transparent; border: none; color: var(--text-color); font-family: 'Roboto', sans-serif; font-size: 1rem; padding: 10px; resize: none; outline: none; text-align: center; }
        #note-display { white-space: pre-wrap; word-wrap: break-word; user-select: none; }
        #note-textarea { display: none; }
        #note-widget.edit-mode #note-display { display: none; }
        #note-widget.edit-mode #note-textarea { display: block; }
        #note-settings-btn { position: absolute; top: 8px; right: 8px; width: 28px; height: 28px; background-color: rgba(0,0,0,0.5); color: white; border-radius: 50%; display: none; justify-content: center; align-items: center; font-size: 16px; cursor: pointer; z-index: 12; }
        #note-widget.edit-mode #note-settings-btn { display: flex; }

        #music-widget { top: 45%; left: 10%; width: 300px; display: flex; flex-direction: column; justify-content: center; }
        /* Music Visualizer Widget */
        #music-visualizer-widget { top: 70%; left: 10%; width: 320px; height: 140px; padding: 0; overflow: hidden; position: absolute; resize: both; min-width: 180px; min-height: 90px; }
        #music-visualizer-canvas { width: 100%; height: 100%; display: block; }
        #music-visualizer-overlay { position: absolute; inset: 0; display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 8px; background-color: rgba(0,0,0,0.35); color: #fff; text-shadow: var(--text-shadow); font-weight: 500; user-select: none; }
        #music-visualizer-overlay i { font-size: 1.4rem; opacity: 0.9; }
        /* Circle mode: hide blurred box and make circular */
        #music-visualizer-widget.circle-mode { background-color: transparent !important; backdrop-filter: none !important; -webkit-backdrop-filter: none !important; border-radius: 50%; resize: none; }
        #music-visualizer-widget.circle-mode #music-visualizer-canvas { border-radius: 50%; }
        #music-visualizer-widget.circle-mode #music-visualizer-overlay { background-color: transparent; }
        #music-visualizer-resize-box { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); width: 64px; height: 64px; border: 1.5px dashed rgba(255,255,255,0.7); border-radius: 10px; display: none !important; align-items: center; justify-content: center; color: rgba(255,255,255,0.9); cursor: nwse-resize; user-select: none; }
        #music-info-container { display: flex; gap: 12px; align-items: center; }
        #music-album-art { width: 60px; height: 60px; background-size: cover; background-position: center; border-radius: 8px; flex-shrink: 0; display: flex; justify-content: center; align-items: center; font-size: 2rem; background-color: rgba(0,0,0,0.2); }
        #music-details { text-align: left; overflow: hidden; }
        #music-title { font-weight: 500; white-space: nowrap; text-overflow: ellipsis; overflow: hidden; }
        #music-artist { font-size: 0.9em; color: #ccc; white-space: nowrap; text-overflow: ellipsis; overflow: hidden; }
        #music-controls { display: flex; justify-content: space-around; align-items: center; margin-top: 12px; }
        #music-controls i { font-size: 1.5rem; cursor: pointer; transition: transform 0.2s; }
        #music-controls i:hover { transform: scale(1.1); }
        #music-widget.no-station #music-controls { display: none; }
        #gif-widget { top: 25%; left: 75%; width: 200px; height: 200px; padding: 0; background-color: transparent; backdrop-filter: none; resize: both; overflow: hidden; display: flex; align-items: center; justify-content: center; border: 2px dashed rgba(255, 255, 255, 0.2); border-radius: 12px; }
        #gif-widget.has-gif { border: none; }
        #gif-widget-placeholder { font-size: 4rem; color: rgba(255, 255, 255, 0.5); }
        #gif-display { width: 100%; height: 100%; object-fit: contain; }
        #remove-gif-btn { position: absolute; top: 5px; right: 5px; width: 24px; height: 24px; background-color: rgba(231, 76, 60, 0.8); color: white; border-radius: 50%; display: none; justify-content: center; align-items: center; font-size: 16px; cursor: pointer; z-index: 12; }
        #gif-widget.has-gif:hover #remove-gif-btn { display: flex; }
        
        /* Webcam Widget CSS */
        #webcam-widget { top: 20%; left: 20%; width: 320px; height: 240px; padding: 0; resize: none; overflow: hidden; display: flex; align-items: center; justify-content: center; background-color: #000; border: 1px solid var(--widget-bg); transition: box-shadow 0.3s, border-color 0.3s; }
        .webcam-video-wrapper { display: none; width: 100%; height: 100%; transform: scaleX(-1); /* Default to mirrored */ touch-action: none; /* For Pointer Events */ cursor: pointer; }
        .webcam-video-wrapper.panning { cursor: grabbing; }
        .webcam-video-wrapper.normal-view { transform: scaleX(1); /* Class to un-mirror */ }
        #webcam-canvas { width: 100%; height: 100%; filter: grayscale(100%); transition: transform 0.1s ease-out; /* Smooth pan/zoom */ transform-origin: center center; }
        #webcam-widget.active .webcam-video-wrapper { display: block; }
        #webcam-widget.active #webcam-placeholder { display: none; }
        #webcam-widget.webcam-pan-zoom-active { box-shadow: 0 0 15px rgba(10, 132, 255, 0.7); border-color: #0a84ff; }
        #webcam-widget.webcam-pan-zoom-active .webcam-video-wrapper { cursor: grab; }
        #webcam-widget.webcam-pan-zoom-active .webcam-video-wrapper:hover { cursor: grab; }
        #webcam-placeholder { display: flex; flex-direction: column; align-items: center; gap: 10px; font-size: 1.2rem; color: rgba(255, 255, 255, 0.7); text-align: center; padding: 10px; }
        #webcam-controls { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); display: flex; align-items: center; gap: 10px; background-color: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 8px; opacity: 0; transition: opacity 0.3s ease; z-index: 12; }
        #webcam-widget:hover #webcam-controls { opacity: 1; }
        #webcam-source-select { background-color: #333; color: white; border: 1px solid #555; border-radius: 5px; padding: 3px; max-width: 150px; }
        #webcam-stop-btn { background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 0; line-height: 1; display: flex; align-items: center; }

        /* NEW: Webcam Toggle Button */
        #webcam-toggle-btn {
            top: 80%;
            left: 130px; /* Initial position next to settings icon */
            background-color: rgba(80, 80, 80, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
        }
        #webcam-toggle-btn i {
            font-size: 28px;
            color: white;
        }

        #lock-screen.light-theme #music-artist { color: #555; }
        #settings-btn { top: 80%; left: 50px; }
        #settings-btn svg circle:nth-child(2) { stroke: var(--icon-stroke-color); }
        #settings-menu, #stock-editor-menu, #note-editor-menu, #radio-menu, #gif-chooser-menu { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); display: none; justify-content: center; align-items: center; z-index: 1000; opacity: 0; transition: opacity 0.3s ease; }
        #settings-menu.visible, #stock-editor-menu.visible, #note-editor-menu.visible, #radio-menu.visible, #gif-chooser-menu.visible { display: flex; opacity: 1; }
        .menu-content { background-color: #2c2c2e; padding: 30px; border-radius: 20px; width: 90%; max-width: 500px; color: #f2f2f7; text-align: left; position: relative; box-shadow: 0 5px 25px rgba(0,0,0,0.5); transform: scale(0.95); transition: transform 0.3s ease; }
        #radio-menu .menu-content, #gif-chooser-menu .menu-content { max-height: 80vh; overflow-y: auto; }
        #stock-editor-menu .menu-content { text-align: center; }
        #settings-menu.visible .menu-content, #stock-editor-menu.visible .menu-content, #note-editor-menu.visible .menu-content, #radio-menu.visible .menu-content, #gif-chooser-menu.visible .menu-content { transform: scale(1); }
        .menu-content h2 {text-align: center;}
        #close-settings-btn, #close-stock-editor-btn, #close-note-editor-btn, #close-radio-btn, #close-gif-chooser-btn { position: absolute; top: 10px; right: 15px; background: none; border: none; color: #aaa; font-size: 2rem; cursor: pointer; line-height: 1; z-index: 5; }
        #wallpaper-url-input, #stock-symbols-input, #weather-location-input, #font-select, #clock-color-input, #note-font-select, #note-font-size-input { width: 100%; padding: 12px; margin-bottom: 10px; border-radius: 10px; border: 1px solid #555; background-color: #3a3a3c; color: white; font-size: 1rem; outline: none; }
        #note-font-size-input { -moz-appearance: textfield; } #note-font-size-input::-webkit-outer-spin-button, #note-font-size-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        #clock-color-input { padding: 5px; height: 50px; }
        #stock-symbols-input { margin: 10px 0; text-transform: uppercase; text-align: center; }
        #save-stocks-btn, #qr-upload-btn, #reset-positions-btn, #add-new-gif-btn { background-color: #0a84ff; color: white; border: none; padding: 10px 15px; border-radius: 8px; cursor: pointer; font-size: 0.9em; margin-top: 10px; }
        #add-new-gif-btn { width: 100%; display: flex; align-items: center; justify-content: center; gap: 8px; }
        #reset-positions-btn { background-color: #e74c3c; width: 100%; }
        .settings-section { margin-top: 25px; border-top: 1px solid #444; padding-top: 20px; }
        .settings-section:first-child { margin-top: 0; border-top: none; padding-top: 0; }
        .settings-section h3, .settings-section > label { margin-bottom: 5px; text-align: center; display: block; } .settings-section h4 { margin-top: 15px; margin-bottom: 5px; color: #ccc; font-weight: 500; }
        .setting-toggle { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; }
        .settings-footer button { background: none; border: none; color: #aeb0b5; width: 100%; text-align: center; padding: 12px 0; font-size: 1em; font-weight: 500; display: flex; justify-content: center; align-items: center; gap: 10px; border-radius: 8px; transition: background-color 0.2s, color 0.2s; cursor: pointer; }
        .settings-footer button:hover { background-color: rgba(255, 255, 255, 0.1); color: #fff; }
        #wallpaper-choices, #gif-choices { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px; max-height: 200px; overflow-y: auto; padding: 10px; background-color: #1c1c1e; border-radius: 10px; }
        #gif-choices { max-height: 400px; }
        .wallpaper-thumbnail, .gif-thumbnail { position: relative; width: 100%; padding-bottom: 100%; background-size: cover; background-position: center; border-radius: 8px; cursor: pointer; border: 2px solid transparent; transition: border-color 0.2s, transform 0.2s; background-color: #333;}
        .gif-thumbnail img { width: 100%; height: 100%; object-fit: cover; position: absolute; top: 0; left: 0; border-radius: 6px;}
        .wallpaper-thumbnail:hover, .gif-thumbnail:hover { border-color: #0a84ff; transform: scale(1.05); }
        .remove-thumb-btn { position: absolute; top: 2px; right: 2px; width: 20px; height: 20px; background-color: rgba(0,0,0,0.6); color: white; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 14px; line-height: 20px; font-family: sans-serif; cursor: pointer; opacity: 0; transition: opacity 0.2s; z-index: 2;}
        .wallpaper-thumbnail:hover .remove-thumb-btn, .gif-thumbnail:hover .remove-thumb-btn { opacity: 1; }
        #radio-channel-list { margin-top: 20px; }
        .radio-channel-item { padding: 15px; border-bottom: 1px solid #444; cursor: pointer; transition: background-color 0.2s; }
        .radio-channel-item:hover { background-color: rgba(255,255,255,0.1); }
        .radio-channel-item:last-child { border-bottom: none; }
        .radio-channel-item .name { font-weight: 500; }
        .radio-channel-item .genre { font-size: 0.9em; color: #aaa; margin-top: 4px; }
        #fullscreen-hint { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background-color: rgba(0,0,0,0.4); padding: 8px 15px; border-radius: 12px; color: #f0f0f0; text-shadow: 1px 1px 3px rgba(0,0,0,0.5); opacity: 0; transition: opacity 1s ease-out; z-index: 25; pointer-events: none; }
        #unlock-prompt, #fullscreen-hint.visible { opacity: 1; }
        #unlock-prompt.visible { pointer-events: auto; }
        #unlock-prompt { position: absolute; bottom: 20%; left: 50%; transform: translateX(-50%); color: white; font-size: 1.3rem; font-weight: 500; text-shadow: 1px 1px 8px rgba(0,0,0,0.8); user-select: none; cursor: pointer; opacity: 0; pointer-events: none; transition: opacity 0.7s ease; z-index: 25; }
        .hidden { display: none !important; }
        #qr-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); backdrop-filter: blur(10px); display: none; justify-content: center; align-items: center; z-index: 1001; }
        #qr-modal-content { background: #fff; padding: 25px; border-radius: 16px; text-align: center; color: #333; }
        #qr-code { padding: 10px; background: white; margin-bottom: 15px; display: inline-block; } #qr-code img { display: block; margin: auto; }
        #upload-view { display: none; justify-content: center; align-items: center; width: 100%; height: 100%; padding: 20px; }
        #phone-upload-container { display: flex; flex-direction: column; width: 90%; max-width: 400px; gap: 10px; text-align: center; }
        #phone-upload-container h2 { color: #f2f2f7; }
        #phone-upload-container p { color: #aeb0b5; font-size: 0.9rem; margin: 0; }
        #phone-url-input { width: 100%; padding: 15px; border-radius: 10px; border: 1px solid #555; background-color: #3a3a3c; color: white; font-size: 1rem; outline: none; }
        #phone-url-submit { background-color: #0a84ff; color: white; border: none; padding: 15px 20px; border-radius: 10px; cursor: pointer; font-size: 1.1rem; font-weight: 500; }
        #phone-url-submit:disabled { background-color: #555; cursor: not-allowed; }
        #upload-label { display: inline-block; background-color: #34c759; color: white; padding: 15px 20px; border-radius: 10px; cursor: pointer; font-size: 1.1rem; font-weight: 500; }
        .separator-text { margin: 5px 0; font-style: italic; color: #888; }
        .stock-flash-toggle { display: flex; justify-content: center; align-items: center; gap: 10px; margin-top: 20px; font-family: 'Roboto', sans-serif; }
        #stock-flash-checkbox { width: 20px; height: 20px; }
        .flash-overlay { position: fixed; left: 0; width: 100%; height: 40%; z-index: 9999; pointer-events: none; opacity: 0; }
        #flash-top { top: 0; background: radial-gradient(ellipse at top, rgba(46, 204, 113, 0.5) 0%, rgba(46, 204, 113, 0) 80%); }
        #flash-bottom { bottom: 0; background: radial-gradient(ellipse at bottom, rgba(231, 76, 60, 0.5) 0%, rgba(231, 76, 60, 0) 80%); }
        .flash-active { animation: flash-in-out 1.5s ease-out; }
        #flash-top.super-flash { background: radial-gradient(ellipse at top, rgba(46, 204, 113, 0.9) 0%, rgba(46, 204, 113, 0) 75%); }
        #flash-bottom.super-flash { background: radial-gradient(ellipse at bottom, rgba(231, 76, 60, 0.9) 0%, rgba(231, 76, 60, 0) 75%); }
        @keyframes flash-in-out { 0% { opacity: 0; } 20% { opacity: 1; } 100% { opacity: 0; } }
        .raining-icon { position: fixed; top: -50px; font-size: 2rem; z-index: 9998; pointer-events: none; opacity: 0.7; text-shadow: 0 0 10px rgba(0,0,0,0.5); }
        .raining-icon.up { color: #2ecc71; animation-name: rise-anim; }
        .raining-icon.down { color: #e74c3c; animation-name: fall-anim; }
        @keyframes fall-anim { from { transform: translateY(-10vh) rotate(0deg); opacity: 1; } to { transform: translateY(110vh) rotate(720deg); opacity: 0; } }
        @keyframes rise-anim { from { transform: translateY(110vh) rotate(0deg); opacity: 1; } to { transform: translateY(-10vh) rotate(720deg); opacity: 0; } }
        #fun-stock-name-display { position: absolute; bottom: 20vh; right: 5vw; font-size: 2.5rem; font-family: 'Oswald', sans-serif; color: var(--text-color); text-shadow: var(--text-shadow); opacity: 0; transition: opacity 1.5s ease-in-out; pointer-events: none; }
        #fun-stock-name-display.visible { opacity: 1; pointer-events: auto; }
        #lock-screen.light-theme { --icon-stroke-color: #333; }
        #lock-screen.light-theme #clock { color: #333; filter: drop-shadow(0 0 10px rgba(255,255,255,0.3));}
        #lock-screen.light-theme #status-bar, #lock-screen.light-theme #unlock-prompt, #lock-screen.light-theme #fullscreen-hint, #lock-screen.light-theme #fun-stock-name-display { color: var(--text-color-light); text-shadow: var(--text-shadow-light); }
        #lock-screen.light-theme .widget, #lock-screen.light-theme #weather-info { background-color: var(--widget-bg-light); color: var(--text-color-light); text-shadow: var(--text-shadow-light); }
        #lock-screen.light-theme #note-textarea, #lock-screen.light-theme #note-display { color: var(--text-color-light); }
    </style>
</head>
<body>
    <audio id="audio-player" preload="none"></audio>
    <div id="lock-screen">
        <div id="status-bar"><div id="weather-info"><span id="date"></span> <i id="weather-icon" class="fa-solid fa-cloud-sun"></i> <span id="temperature">...</span></div></div>
        <div id="fullscreen-hint">Double press wallpaper for fullscreen</div>
        <div id="clock" class="draggable-item"><div id="hours">00</div><div id="minutes">00</div></div>
        <div id="youtube-music-btn" class="draggable-item app-icon" role="button" tabindex="0" aria-label="Open YouTube Music"><a href="https://music.youtube.com/" target="_blank" rel="noopener noreferrer"><svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><circle cx="50" cy="50" r="50" fill="#FF0000"/><circle cx="50" cy="50" r="23" fill="none" stroke="white" stroke-width="4"/><polygon points="43,38 62,50 43,62" fill="white"/></svg></a></div>
        <div id="youtube-btn" class="draggable-item app-icon" role="button" tabindex="0" aria-label="Open YouTube"><a href="https://www.youtube.com/" target="_blank" rel="noopener noreferrer"><svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><circle cx="50" cy="50" r="50" fill="#FF0000"/><path d="M 35,29 A 10,10 0 0 0 25,39 V 61 A 10,10 0 0 0 35,71 H 65 A 10,10 0 0 0 75,61 V 39 A 10,10 0 0 0 65,29 Z" fill="white"/><polygon points="45,42 62,50 45,58" fill="#FF0000"/></svg></a></div>
        
        <!-- Widgets -->
        <div id="stock-widget" class="draggable-item widget" title="Single-click to trigger effect | Double-click to edit"></div>
        
        <div id="note-widget" class="draggable-item widget" title="Double-click to edit">
            <div id="note-display"></div>
            <textarea id="note-textarea" placeholder="Type a note..."></textarea>
            <div id="note-settings-btn" title="Edit note style"><i class="fa-solid fa-cog"></i></div>
        </div>

        <div id="music-widget" class="draggable-item widget no-station" title="Double-click to select radio">
            <div id="music-info-container">
                <div id="music-album-art"></div>
                <div id="music-details">
                    <div id="music-title">No Station Loaded</div>
                    <div id="music-artist">Double click to select</div>
                </div>
            </div>
            <div id="music-controls">
                <i id="music-prev" class="fa-solid fa-backward-step"></i>
                <i id="music-play-pause" class="fa-solid fa-play"></i>
                <i id="music-next" class="fa-solid fa-forward-step"></i>
            </div>
        </div>
        <div id="music-visualizer-widget" class="draggable-item widget" title="Tap to start/stop microphone visualizer">
            <canvas id="music-visualizer-canvas"></canvas>
            <div id="music-visualizer-overlay"><i class="fa-solid fa-microphone"></i><span>Tap to start</span></div>
            <div id="music-visualizer-resize-box"><i class="fa-solid fa-up-right-and-down-left-from-center"></i></div>
        </div>
        <div id="gif-widget" class="draggable-item" title="Click to add GIF | Double-click to choose">
            <i id="gif-widget-placeholder" class="fa-solid fa-image"></i>
            <img id="gif-display" alt="Selected GIF">
            <div id="remove-gif-btn">×</div>
        </div>

        <div id="webcam-widget" class="draggable-item widget" title="Long-press feed to mirror | Dbl-click feed for pan/zoom">
            <div class="webcam-video-wrapper">
                <canvas id="webcam-canvas"></canvas>
                <div id="webcam-controls">
                    <select id="webcam-source-select"><option>No Cams</option></select>
                    <button id="webcam-stop-btn" title="Stop Camera"><i class="fa-solid fa-power-off"></i></button>
                </div>
                <video id="webcam-video-source" playsinline muted style="display: none;"></video>
            </div>
            <div id="webcam-placeholder"><i class="fa-solid fa-video-slash"></i><span>Camera Inactive</span></div>
        </div>

        <!-- CORRECTED ID AND LOGIC FOR THIS BUTTON -->
        <button id="webcam-portrait-btn" style="position: absolute; opacity: 0; pointer-events: none; transition: opacity 0.5s; z-index: 20; background: rgba(0,0,0,0.7); color: #fff; border: none; border-radius: 8px; padding: 8px 18px; font-size: 1.1em;">9:16</button>

        <!-- NEW: Webcam Toggle Button -->
        <div id="webcam-toggle-btn" class="draggable-item app-icon hidden" title="Toggle Rear Seat Cam" role="button" tabindex="0" aria-label="Toggle Rear Seat Cam">
            <i class="fa-solid fa-video-slash"></i>
        </div>

        <div id="settings-btn" class="draggable-item app-icon" title="Open settings menu" role="button" tabindex="0" aria-label="Open settings"><svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><circle cx="8" cy="8" r="7.5" fill="rgba(80, 80, 80, 0.6)"/><circle cx="8" cy="8" r="4" fill="none" stroke="var(--icon-stroke-color)" stroke-width="1.5"/></svg></div>
        <div id="fun-stock-name-display" class="draggable-item"></div>
        <div id="unlock-prompt">Press to unlock</div>
    </div>
    <div id="settings-menu">
        <div class="menu-content">
            <button id="close-settings-btn">×</button>
            <h2 id="settings-title">Wallpapers</h2>
            <div id="advanced-settings-view" class="hidden">
                 <div class="settings-section">
                    <h3>Widget Visibility</h3>
                    <div class="setting-toggle"><label for="toggle-stock-widget">Stock Widget</label><input type="checkbox" id="toggle-stock-widget"></div>
                    <div class="setting-toggle"><label for="toggle-note-widget">Note Widget</label><input type="checkbox" id="toggle-note-widget"></div>
                    <div class="setting-toggle"><label for="toggle-music-widget">Music Widget</label><input type="checkbox" id="toggle-music-widget"></div>
                     <div class="setting-toggle"><label for="toggle-music-visualizer-widget">Music Visualizer</label><input type="checkbox" id="toggle-music-visualizer-widget"></div>
                    <div class="setting-toggle"><label for="toggle-gif-widget">GIF Widget</label><input type="checkbox" id="toggle-gif-widget"></div>
                    <div class="setting-toggle"><label for="toggle-webcam-widget">Rear Seat Cam</label><input type="checkbox" id="toggle-webcam-widget"></div>
                </div>
                <div class="settings-section">
                    <h3>Theme & Style</h3>
                    <div class="setting-toggle"><label for="theme-toggle">Light Theme</label><input type="checkbox" id="theme-toggle"></div>
                    <label for="clock-color-input">Clock Color</label>
                    <input type="color" id="clock-color-input" value="#ffffff">
                    <label for="font-select">Clock Font</label>
                    <select id="font-select">
                        <option value="'Oswald', sans-serif">Oswald (Default)</option>
                        <option value="'Playfair Display', serif">Playfair Display</option>
                        <option value="'Source Code Pro', monospace">Source Code Pro</option>
                    </select>
                </div>
                <div class="settings-section">
                    <h3>Weather Location</h3>
                    <p>Enter a city name or leave blank for auto-detection.</p>
                    <input type="text" id="weather-location-input" placeholder="e.g., London">
                </div>
            </div>
            <div id="wallpaper-section">
                <div class="settings-section">
                    <h3>Wallpaper</h3>
                    <p>Paste an image URL below or add from phone.</p>
                    <input type="text" id="wallpaper-url-input" placeholder="https://example.com/image.jpg">
                    <button id="qr-upload-btn">Add from Phone</button>
                    <h4>Your Wallpapers</h4>
                    <div id="wallpaper-choices"></div>
                </div>
            </div>
            <div id="advanced-settings-footer" class="hidden">
                <div class="settings-section">
                    <button id="reset-positions-btn">Reset All Positions</button>
                </div>
            </div>
            <div class="settings-section settings-footer" id="settings-footer">
                <button id="show-advanced-settings-btn"><i class="fa-solid fa-sliders"></i> Show Full Settings</button>
                <button id="hide-advanced-settings-btn" class="hidden"><i class="fa-solid fa-arrow-left"></i> Back to Wallpapers</button>
            </div>
        </div>
    </div>
    <div id="stock-editor-menu"><div class="menu-content"><button id="close-stock-editor-btn">×</button><h2>Edit Stock Symbols</h2><p>Enter up to 7 stock symbols, separated by commas.</p><input type="text" id="stock-symbols-input" placeholder="TSLA, GOOGL, AKBA..."><div class="stock-flash-toggle"><label for="stock-flash-checkbox">Stock Flash 🎉</label><input type="checkbox" id="stock-flash-checkbox"></div><button id="save-stocks-btn">Save and Update</button></div></div>
    <div id="note-editor-menu"><div class="menu-content"><button id="close-note-editor-btn">×</button><h2>Edit Note Style</h2><div class="settings-section"><label for="note-font-select">Font Family</label><select id="note-font-select"><option value="'Roboto', sans-serif">Roboto (Default)</option><option value="'Lora', serif">Lora</option><option value="'Inter', sans-serif">Inter</option><option value="'Source Code Pro', monospace">Source Code Pro</option></select></div><div class="settings-section"><label for="note-font-size-input">Font Size (px)</label><input type="text" id="note-font-size-input" inputmode="numeric" pattern="[0-9]*" value="16"></div></div></div>
    <div id="radio-menu"><div class="menu-content"><button id="close-radio-btn">×</button><h2>Select a Radio Station</h2><div id="radio-channel-list"></div></div></div>
    <div id="gif-chooser-menu"><div class="menu-content"><button id="close-gif-chooser-btn">×</button><h2>Choose a GIF</h2><div id="gif-choices"></div><button id="add-new-gif-btn"><i class="fa-solid fa-plus"></i> Add New GIF</button></div></div>
    <div id="qr-modal"><div id="qr-modal-content"><h2>Scan with your phone</h2><div id="qr-code"></div><p>Scan to send an image URL from your phone.</p></div></div>
    <div id="upload-view"><div id="phone-upload-container"><h2>Add Wallpaper from Phone</h2><label for="file-input" id="upload-label">Tap to Upload Image</label><input type="file" id="file-input" accept="image/*" style="display: none;"><p class="separator-text">... or ...</p><p>Paste an image URL below</p><input type="url" id="phone-url-input" placeholder="https://example.com/image.jpg"><button id="phone-url-submit">Use this URL</button><h2 id="upload-status"></h2></div></div>
    <div id="flash-top" class="flash-overlay"></div>
    <div id="flash-bottom" class="flash-overlay"></div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const NPOINT_BIN_ID = 'f76d79c771a62c1ce33a';
            const lockScreen = document.getElementById('lock-screen');
            const clock = document.getElementById('clock');
            const qrModal = document.getElementById('qr-modal');
            const initialWallpaper = { url: 'https://images.pexels.com/photos/807598/pexels-photo-807598.jpeg', position: 'center center' };
            let isPanningMode = false, currentWallpaperImg = new Image(), pollingInterval, clickTimer, inactivityTimer, pressHoldTimer;
            let hasMovedWp = false;
            let stockFlashIndex = 0;
            let stockNameFadeOutTimer = null;
            let stockWidgetClickTimer = null;
            window.isWebcamPanZoomMode = false;
            currentWallpaperImg.crossOrigin = "Anonymous";

            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('upload') && urlParams.has('session')) {
                document.body.style.backgroundColor = '#1a1a1a';
                ['lock-screen', 'settings-menu', 'stock-editor-menu', 'qr-modal'].forEach(id => { const el = document.getElementById(id); if (el) el.style.display = 'none'; });
                document.getElementById('upload-view').style.display = 'flex';
                handlePhoneUpload(urlParams.get('session'));
            } else {
                initializeLockscreen();
            }

            function handlePhoneUpload(session) {
                const IMGBB_API_KEY = '4418969a1a33c4e2ea690d835d915e52';
                const fileInput = document.getElementById('file-input');
                const urlInput = document.getElementById('phone-url-input');
                const urlSubmitBtn = document.getElementById('phone-url-submit');
                const statusElem = document.getElementById('upload-status');
                const uploadLabel = document.getElementById('upload-label');
                const sendUrlToLockscreen = (imageUrl) => {
                    statusElem.textContent = 'Sending to PC...';
                    fileInput.disabled = true; urlInput.disabled = true; urlSubmitBtn.disabled = true;
                    uploadLabel.style.backgroundColor = '#555';
                    fetch(`https://api.npoint.io/${NPOINT_BIN_ID}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ [session]: imageUrl }) })
                    .then(r => { if (!r.ok) throw new Error('Failed to update PC.'); statusElem.textContent = 'Success! You can close this window.'; })
                    .catch(e => { statusElem.textContent = `Error: ${e.message}`; fileInput.disabled = false; urlInput.disabled = false; urlSubmitBtn.disabled = false; uploadLabel.style.backgroundColor = '#34c759'; });
                };
                fileInput.addEventListener('change', (e) => { const file = e.target.files[0]; if (!file) return; statusElem.textContent = 'Uploading to ImgBB...'; const formData = new FormData(); formData.append('key', IMGBB_API_KEY); formData.append('image', file); fetch('https://api.imgbb.com/1/upload', { method: 'POST', body: formData }).then(response => response.json()).then(data => { if (data.success) { sendUrlToLockscreen(data.data.url); } else { throw new Error(data.error.message || 'ImgBB upload failed.'); } }).catch(error => { statusElem.textContent = `Error: ${error.message}`; }); });
                urlSubmitBtn.addEventListener('click', () => { const imageUrl = urlInput.value.trim(); if (!imageUrl || !imageUrl.startsWith('http')) { statusElem.textContent = 'Please enter a valid image URL.'; return; } sendUrlToLockscreen(imageUrl); });
            }

            function initializeLockscreen() {
                const settingsMenu = document.getElementById('settings-menu');
                const closeSettingsBtn = document.getElementById('close-settings-btn');
                const fullscreenHint = document.getElementById('fullscreen-hint');
                const unlockPrompt = document.getElementById('unlock-prompt');
                let wallpaperReady = false;
                
                const advancedSettingsView = document.getElementById('advanced-settings-view');
                const advancedSettingsFooter = document.getElementById('advanced-settings-footer');
                const showAdvancedBtn = document.getElementById('show-advanced-settings-btn');
                const hideAdvancedBtn = document.getElementById('hide-advanced-settings-btn');
                const settingsTitle = document.getElementById('settings-title');
                const wallpaperSection = document.getElementById('wallpaper-section');

                const showFullSettings = () => {
                    advancedSettingsView.classList.remove('hidden');
                    advancedSettingsFooter.classList.remove('hidden');
                    showAdvancedBtn.classList.add('hidden');
                    hideAdvancedBtn.classList.remove('hidden');
                    wallpaperSection.classList.add('hidden');
                    settingsTitle.textContent = 'Full Settings';
                };
                const showWallpaperSettings = () => {
                    advancedSettingsView.classList.add('hidden');
                    advancedSettingsFooter.classList.add('hidden');
                    showAdvancedBtn.classList.remove('hidden');
                    hideAdvancedBtn.classList.add('hidden');
                    wallpaperSection.classList.remove('hidden');
                    settingsTitle.textContent = 'Wallpapers';
                };

                showAdvancedBtn.addEventListener('click', showFullSettings);
                hideAdvancedBtn.addEventListener('click', showWallpaperSettings);

                closeSettingsBtn.addEventListener('click', () => settingsMenu.classList.remove('visible'));
                settingsMenu.addEventListener('click', (e) => { if (e.target === settingsMenu) settingsMenu.classList.remove('visible'); });

                // No API key required; using Yahoo Finance via allorigins proxy
                
                const stockWidget = document.getElementById('stock-widget');
                const stockEditorMenu = document.getElementById('stock-editor-menu');
                const closeStockEditorBtn = document.getElementById('close-stock-editor-btn');
                const saveStocksBtn = document.getElementById('save-stocks-btn');
                const stockSymbolsInput = document.getElementById('stock-symbols-input');
                const stockFlashCheckbox = document.getElementById('stock-flash-checkbox');

                const getStockSymbols = () => JSON.parse(localStorage.getItem('lockscreenStockSymbols')) || ['NIO'];
                const saveStockSymbols = (symbols) => localStorage.setItem('lockscreenStockSymbols', JSON.stringify(symbols));
                const getStockFlashState = () => localStorage.getItem('lockscreenStockFlashEnabled') === 'true';
                const saveStockFlashState = (isEnabled) => localStorage.setItem('lockscreenStockFlashEnabled', isEnabled);
                
                stockFlashCheckbox.checked = getStockFlashState();
                stockFlashCheckbox.addEventListener('change', () => saveStockFlashState(stockFlashCheckbox.checked));

                function triggerScreenFlash(isUp, isSuper = false) {
                    const flashEl = isUp ? document.getElementById('flash-top') : document.getElementById('flash-bottom');
                    if (isSuper) flashEl.classList.add('super-flash');
                    flashEl.classList.add('flash-active');
                    setTimeout(() => {
                        flashEl.classList.remove('flash-active');
                        if (isSuper) flashEl.classList.remove('super-flash');
                    }, 1500);
                }

                function triggerIconShower(isUp, isSuper = false) {
                    const iconCount = isSuper ? 60 : 20;
                    for (let i = 0; i < iconCount; i++) {
                        const icon = document.createElement('i');
                        icon.className = `fa-solid raining-icon ${isUp ? 'fa-caret-up up' : 'fa-caret-down down'}`;
                        icon.style.left = `${Math.random() * 100}vw`;
                        icon.style.animationDuration = `${(Math.random() * 2) + 3}s`;
                        icon.style.animationDelay = `${Math.random() * 2}s`;
                        icon.style.transform = `scale(${(Math.random() * 0.5) + 0.8})`;
                        icon.addEventListener('animationend', () => icon.remove());
                        document.body.appendChild(icon);
                    }
                }

                function triggerStockFlashEffect(isUp, isSuper, symbol) {
                    const nameDisplay = document.getElementById('fun-stock-name-display');
                    nameDisplay.textContent = symbol;
                    nameDisplay.classList.add('visible');

                    if (stockNameFadeOutTimer) clearTimeout(stockNameFadeOutTimer);

                    setTimeout(() => {
                        triggerScreenFlash(isUp, isSuper);
                        triggerIconShower(isUp, isSuper);
                    }, 1500);

                    stockNameFadeOutTimer = setTimeout(() => {
                        nameDisplay.classList.remove('visible');
                    }, 4500);
                }
                
                function isMarketOpen() {
                    const now = new Date();
                    const day = now.getDay(); 
                    const hour = now.getHours();
                    const minute = now.getMinutes();
                    if (day < 1 || day > 5) return false;
                    const currentTime = hour * 100 + minute;
                    return currentTime >= 1530 && currentTime < 2100;
                }
                
                function handleStockData(data, symbol) {
                    if (!data || typeof data.c === 'undefined' || typeof data.o === 'undefined' || data.o === 0 || data.c === data.o) return;
                    const isUp = data.c > data.o;
                    const percentChange = ((data.c - data.o) / data.o) * 100;
                    const isSuper = Math.abs(percentChange) > 5;
                    triggerStockFlashEffect(isUp, isSuper, symbol);
                }
                
                // Fetch stock quote without API key using Stooq daily CSV via multiple proxies; returns last close and previous close
                function fetchQuoteNoKey(symbol) {
                    const stooqSym = (symbol.includes('.') ? symbol : `${symbol}.us`).toLowerCase();
                    const stooqDailyList = `https://stooq.com/q/d/l/?s=${encodeURIComponent(stooqSym)}&i=d`;
                    const proxyWraps = [
                        (u) => `https://r.jina.ai/http/${u.replace(/^https?:\/\//, '')}`,
                        (u) => `https://api.allorigins.win/raw?url=${encodeURIComponent(u)}`,
                        (u) => `https://cors.isomorphic-git.org/${u}`,
                        (u) => `https://thingproxy.freeboard.io/fetch/${u}`
                    ];

                    const parseStooqSeries = (csv) => {
                        const lines = csv.trim().split(/\r?\n/);
                        if (lines.length < 2) return null;
                        // Remove header line
                        const rows = lines.slice(1).filter(Boolean);
                        const lastRow = rows[rows.length - 1].split(',');
                        const prevRow = rows.length > 1 ? rows[rows.length - 2].split(',') : null;
                        const openToday = parseFloat(lastRow[3]);
                        const closeToday = parseFloat(lastRow[6]);
                        const prevClose = prevRow ? parseFloat(prevRow[6]) : undefined;
                        if (Number.isNaN(closeToday)) return null;
                        return {
                            c: closeToday,
                            // Use previous close as the reference if market is open/unknown; provides day-change direction
                            o: Number.isNaN(openToday) ? (typeof prevClose === 'number' ? prevClose : closeToday) : openToday,
                            p: typeof prevClose === 'number' ? prevClose : closeToday
                        };
                    };

                    const tryFetch = async () => {
                        for (const wrap of proxyWraps) {
                            try {
                                const res = await fetch(wrap(stooqDailyList));
                                const csv = await res.text();
                                const parsed = parseStooqSeries(csv);
                                if (parsed) return parsed;
                            } catch (_) { /* try next proxy */ }
                        }
                        return null;
                    };

                    return tryFetch().then(data => {
                        if (data) saveCachedQuote(symbol, data);
                        return data || getCachedQuote(symbol);
                    });
                }

                function saveCachedQuote(symbol, data) {
                    try { localStorage.setItem(`lockscreenStockCache_v1_${symbol}`, JSON.stringify({ ...data, ts: Date.now() })); } catch {}
                }
                function getCachedQuote(symbol) {
                    try {
                        const raw = localStorage.getItem(`lockscreenStockCache_v1_${symbol}`);
                        if (!raw) return null;
                        const obj = JSON.parse(raw);
                        return obj && typeof obj.c === 'number' ? { c: obj.c, o: obj.o, p: obj.p } : null;
                    } catch { return null; }
                }

                function checkStockFlashTrigger() {
                    if (!getStockFlashState() || !isMarketOpen()) return;
                    const symbols = getStockSymbols();
                    if (symbols.length === 0) return;
                    const symbol = symbols[stockFlashIndex];
                    stockFlashIndex = (stockFlashIndex + 1) % symbols.length;

                    fetchQuoteNoKey(symbol)
                        .then(data => handleStockData(data || getCachedQuote(symbol), symbol))
                        .catch(err => console.error(`Stock Flash fetch error for ${symbol}:`, err));
                }

                function updateStockWidget() {
                    const symbols = getStockSymbols();
                    stockWidget.innerHTML = '';
                    if (symbols.length === 0) return;
                    symbols.forEach(symbol => {
                        const row = document.createElement('div'); row.className = 'stock-row';
                        row.innerHTML = `<div class="stock-info"><i class="fa-solid"></i> ${symbol}</div><span class="stock-price" aria-live="polite">...</span>`;
                        stockWidget.appendChild(row);
                        fetchQuoteNoKey(symbol).then(data => {
                            const priceEl = row.querySelector('.stock-price');
                            const iconEl = row.querySelector('i');
                            const showData = data || getCachedQuote(symbol);
                            if (!showData || typeof showData.c !== 'number') { priceEl.textContent = 'N/A'; return; }
                            priceEl.textContent = (showData.c < 10) ? showData.c.toFixed(3) : showData.c.toFixed(2);
                            iconEl.className = 'fa-solid';
                            if (typeof showData.o === 'number' && showData.o > 0) {
                                if (showData.c > showData.o) iconEl.classList.add('fa-caret-up');
                                else if (showData.c < showData.o) iconEl.classList.add('fa-caret-down');
                            }
                        });
                    });
                }
                
                (function setupWidgets() {
                    const noteWidget = document.getElementById('note-widget');
                    const noteDisplay = document.getElementById('note-display');
                    const noteTextarea = document.getElementById('note-textarea');
                    const noteSettingsBtn = document.getElementById('note-settings-btn');
                    const noteEditorMenu = document.getElementById('note-editor-menu');
                    const closeNoteEditorBtn = document.getElementById('close-note-editor-btn');
                    const noteFontSelect = document.getElementById('note-font-select');
                    const noteFontSizeInput = document.getElementById('note-font-size-input');

                    const enterNoteEditMode = () => {
                        noteWidget.isEditing = true;
                        noteWidget.classList.add('edit-mode');
                        noteTextarea.focus();
                        setTimeout(() => {
                            document.addEventListener('click', exitNoteEditModeOnClickOutside, { once: true });
                        }, 0);
                    };

                    const exitNoteEditMode = () => {
                        noteWidget.isEditing = false;
                        noteWidget.classList.remove('edit-mode');
                        localStorage.setItem('lockscreenNoteContent', noteTextarea.value);
                        noteDisplay.innerText = noteTextarea.value;
                        document.removeEventListener('click', exitNoteEditModeOnClickOutside);
                    };

                    const exitNoteEditModeOnClickOutside = (e) => {
                        if (!noteWidget.contains(e.target)) {
                            exitNoteEditMode();
                        } else {
                           document.addEventListener('click', exitNoteEditModeOnClickOutside, { once: true });
                        }
                    };

                    const applyNoteStyle = () => {
                        const fontFamily = localStorage.getItem('lockscreenNoteFontFamily') || "'Roboto', sans-serif";
                        const fontSize = localStorage.getItem('lockscreenNoteFontSize') || '16';
                        noteTextarea.style.fontFamily = fontFamily;
                        noteTextarea.style.fontSize = `${fontSize}px`;
                        noteDisplay.style.fontFamily = fontFamily;
                        noteDisplay.style.fontSize = `${fontSize}px`;
                        noteFontSelect.value = fontFamily;
                        noteFontSizeInput.value = fontSize;
                    };

                    const savedText = localStorage.getItem('lockscreenNoteContent') || '';
                    noteTextarea.value = savedText;
                    noteDisplay.innerText = savedText;
                    
                    noteTextarea.addEventListener('input', () => { 
                        localStorage.setItem('lockscreenNoteContent', noteTextarea.value);
                        noteDisplay.innerText = noteTextarea.value;
                    });
                    
                    noteWidget.addEventListener('dblclick', (e) => {
                        if (noteWidget.isEditing) return;
                        if (noteWidget.dataset.justDragged !== 'true') {
                            enterNoteEditMode();
                        }
                    });

                    noteSettingsBtn.addEventListener('click', () => {
                        noteEditorMenu.classList.add('visible');
                    });
                    
                    closeNoteEditorBtn.addEventListener('click', () => noteEditorMenu.classList.remove('visible'));
                    noteEditorMenu.addEventListener('click', (e) => { if (e.target === noteEditorMenu) noteEditorMenu.classList.remove('visible'); });
                    noteFontSelect.addEventListener('input', () => { localStorage.setItem('lockscreenNoteFontFamily', noteFontSelect.value); applyNoteStyle(); });
                    noteFontSizeInput.addEventListener('input', () => {
                        const size = parseInt(noteFontSizeInput.value, 10);
                        if (size >= 8 && size <= 48) {
                            localStorage.setItem('lockscreenNoteFontSize', size);
                            applyNoteStyle();
                        }
                    });
                    applyNoteStyle();

                    // Music Widget
                    const radioPlayer = {
                        stations: [
                            { name: 'Lofi Girl', genre: 'Beats to relax/study to', streamUrl: 'https://play.streamafrica.net/lofiradio' },
                            { name: 'SomaFM: Groove Salad', genre: 'Ambient Downtempo', streamUrl: 'https://ice1.somafm.com/groovesalad-128-mp3' },
                            { name: 'SomaFM: Underground 80s', genre: 'Early 80s UK Synthpop', streamUrl: 'https://ice2.somafm.com/u80s-128-mp3' },
                            { name: 'Phonk', genre: 'Classic & Modern Phonk', streamUrl: 'https://stream.laut.fm/phonk' },
                            { name: 'SomaFM: Vaporwaves', genre: 'Hypnagogic Retro', streamUrl: 'https://ice1.somafm.com/vaporwaves-128-mp3' }
                        ],
                        currentStationIndex: -1,
                        currentArtworkUrl: '',
                        audio: document.getElementById('audio-player'),
                        elements: {
                            widget: document.getElementById('music-widget'),
                            art: document.getElementById('music-album-art'),
                            title: document.getElementById('music-title'),
                            artist: document.getElementById('music-artist'),
                            playPause: document.getElementById('music-play-pause'),
                            next: document.getElementById('music-next'),
                            prev: document.getElementById('music-prev'),
                            radioMenu: document.getElementById('radio-menu'),
                            closeRadioBtn: document.getElementById('close-radio-btn'),
                            radioChannelList: document.getElementById('radio-channel-list')
                        },
                        init() {
                            this.elements.widget.addEventListener('dblclick', (e) => { if (e.target.closest('#music-controls')) return; this.openRadioMenu(); });
                            this.elements.closeRadioBtn.addEventListener('click', () => this.elements.radioMenu.classList.remove('visible'));
                            this.elements.playPause.addEventListener('click', () => this.togglePlay());
                            this.elements.next.addEventListener('click', () => this.playNext());
                            this.elements.prev.addEventListener('click', () => this.playPrev());
                            this.audio.addEventListener('play', () => this.updatePlayState(true));
                            this.audio.addEventListener('pause', () => this.updatePlayState(false));
                            this.elements.art.style.backgroundImage = 'none';
                            this.elements.art.innerHTML = '<i class="fa-solid fa-headphones"></i>';
                            this.setupMediaSession();
                        },
                        updateAlbumArt(artUrl) {
                            if (artUrl) this.currentArtworkUrl = artUrl;
                            // Don't show wallpaper in music widget - keep default music icon
                            this.elements.art.innerHTML = '<i class="fa-solid fa-headphones"></i>';
                            this.elements.art.style.backgroundImage = 'none';
                            // Still send artwork to media session API for system controls
                            if (this.currentStationIndex !== -1 && 'mediaSession' in navigator) {
                                const station = this.stations[this.currentStationIndex];
                                navigator.mediaSession.metadata = new MediaMetadata({
                                    title: station.name,
                                    artist: station.genre,
                                    artwork: [{ src: this.currentArtworkUrl, sizes: '512x512', type: 'image/jpeg' }]
                                });
                            }
                        },
                        updatePlayState(isPlaying) { this.elements.playPause.className = `fa-solid ${isPlaying ? 'fa-pause' : 'fa-play'}`; },
                        togglePlay() { if (this.currentStationIndex !== -1) this.audio.paused ? this.audio.play() : this.audio.pause(); },
                        playNext() { this.loadStation((this.currentStationIndex + 1) % this.stations.length); },
                        playPrev() { this.loadStation((this.currentStationIndex - 1 + this.stations.length) % this.stations.length); },
                        loadStation(index) {
                            if (this.currentStationIndex === index && !this.audio.paused) return;
                            this.currentStationIndex = index;
                            const station = this.stations[index];
                            this.elements.widget.classList.remove('no-station');
                            this.elements.title.textContent = station.name;
                            this.elements.artist.textContent = station.genre;
                            this.audio.src = station.streamUrl;
                            this.audio.play().catch(e => console.error("Audio play failed:", e));
                            this.updateAlbumArt(); 
                        },
                        openRadioMenu() {
                            this.elements.radioChannelList.innerHTML = '';
                            this.stations.forEach((station, index) => {
                                const item = document.createElement('div');
                                item.className = 'radio-channel-item';
                                item.innerHTML = `<div class="name">${station.name}</div><div class="genre">${station.genre}</div>`;
                                item.onclick = () => { this.loadStation(index); this.elements.radioMenu.classList.remove('visible'); };
                                this.elements.radioChannelList.appendChild(item);
                            });
                            this.elements.radioMenu.classList.add('visible');
                        },
                        reset() {
                            this.audio.pause(); this.audio.src = ''; this.currentStationIndex = -1;
                            this.elements.widget.classList.add('no-station');
                            this.elements.title.textContent = 'No Station Loaded'; this.elements.artist.textContent = 'Double click to select';
                            this.elements.art.style.backgroundImage = 'none';
                            this.elements.art.innerHTML = '<i class="fa-solid fa-headphones"></i>';
                            this.updatePlayState(false);
                            if (navigator.mediaSession) navigator.mediaSession.metadata = null;
                        },
                        setupMediaSession() {
                            if (!('mediaSession' in navigator)) return;
                            navigator.mediaSession.setActionHandler('play', () => this.togglePlay());
                            navigator.mediaSession.setActionHandler('pause', () => this.togglePlay());
                            navigator.mediaSession.setActionHandler('nexttrack', () => this.playNext());
                            navigator.mediaSession.setActionHandler('previoustrack', () => this.playPrev());
                        }
                    };
                    window.radioPlayer = radioPlayer;
                    radioPlayer.init();

                    // GIF Widget
                    const gifWidget = document.getElementById('gif-widget');
                    const gifDisplay = document.getElementById('gif-display');
                    const gifPlaceholder = document.getElementById('gif-widget-placeholder');
                    const removeGifBtn = document.getElementById('remove-gif-btn');
                    const gifChooserMenu = document.getElementById('gif-chooser-menu');
                    const closeGifChooserBtn = document.getElementById('close-gif-chooser-btn');
                    const gifChoices = document.getElementById('gif-choices');
                    const addNewGifBtn = document.getElementById('add-new-gif-btn');
                    const getGifs = () => JSON.parse(localStorage.getItem('lockscreenGifUrls_v2')) || [];
                    const saveGifs = (gifs) => localStorage.setItem('lockscreenGifUrls_v2', JSON.stringify(gifs));
                    
                    const renderCurrentGif = () => {
                        const lastGif = localStorage.getItem('lockscreenLastGif');
                        const gifs = getGifs();
                        const urlToLoad = lastGif && gifs.includes(lastGif) ? lastGif : (gifs.length > 0 ? gifs[0] : null);
                        
                        if (urlToLoad) {
                            gifDisplay.src = urlToLoad;
                            gifWidget.classList.add('has-gif');
                            gifPlaceholder.style.display = 'none';
                        } else {
                            gifDisplay.src = '';
                            gifWidget.classList.remove('has-gif');
                            gifPlaceholder.style.display = 'flex';
                        }
                    };

                    const addGif = (url) => {
                        if (!url.toLowerCase().endsWith('.gif')) { alert("Invalid URL. Please provide a direct link to a GIF."); return; }
                        const gifs = getGifs();
                        if (!gifs.includes(url)) { gifs.push(url); }
                        saveGifs(gifs);
                        localStorage.setItem('lockscreenLastGif', url);
                        renderCurrentGif();
                    };

                    const openGifChooser = () => {
                        const gifs = getGifs();
                        gifChoices.innerHTML = '';
                        if (gifs.length === 0) {
                            gifChoices.innerHTML = '<p style="text-align:center;color:#aaa;">No GIFs added yet. Click the widget on the lockscreen to add one.</p>';
                        } else {
                            gifs.forEach(gifUrl => {
                                const thumb = document.createElement('div');
                                thumb.className = 'gif-thumbnail';
                                thumb.innerHTML = `<img src="${gifUrl}" alt="GIF thumbnail">`;
                                const rmvBtn = document.createElement('span');
                                rmvBtn.className = 'remove-thumb-btn';
                                rmvBtn.innerHTML = '×';
                                rmvBtn.onclick = (e) => {
                                    e.stopPropagation();
                                    const newGifs = getGifs().filter(url => url !== gifUrl);
                                    saveGifs(newGifs);
                                    if (localStorage.getItem('lockscreenLastGif') === gifUrl) localStorage.removeItem('lockscreenLastGif');
                                    renderCurrentGif();
                                    openGifChooser();
                                };
                                thumb.appendChild(rmvBtn);
                                thumb.onclick = () => {
                                    localStorage.setItem('lockscreenLastGif', gifUrl);
                                    renderCurrentGif();
                                    gifChooserMenu.classList.remove('visible');
                                };
                                gifChoices.appendChild(thumb);
                            });
                        }
                        gifChooserMenu.classList.add('visible');
                    };
                    
                    removeGifBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const currentSrc = gifDisplay.src;
                        const newGifs = getGifs().filter(url => url !== currentSrc);
                        saveGifs(newGifs);
                        if (localStorage.getItem('lockscreenLastGif') === currentSrc) localStorage.removeItem('lockscreenLastGif');
                        renderCurrentGif();
                    });

                    addNewGifBtn.addEventListener('click', () => {
                        gifChooserMenu.classList.remove('visible');
                        window.startPolling(`gif_session_${Date.now()}`, 'gif');
                    });

                    gifWidget.addEventListener('click', (e) => { if (gifWidget.dataset.justDragged !== 'true' && !gifWidget.classList.contains('has-gif')) window.startPolling(`gif_session_${Date.now()}`, 'gif'); });
                    gifWidget.addEventListener('dblclick', (e) => { if (gifWidget.dataset.justDragged !== 'true') openGifChooser(); });
                    closeGifChooserBtn.addEventListener('click', () => gifChooserMenu.classList.remove('visible'));
                    window.addGif = addGif;
                    renderCurrentGif();

                     // Music Visualizer (Microphone)
                     const mv = {
                         audioCtx: null,
                         analyser: null,
                         dataArray: null,
                         timeArray: null,
                         stream: null,
                         rafId: null,
                         level: 0,
                         mode: (localStorage.getItem('musicVisualizerMode') || 'bars'),
                         _clickTimer: null,
                         _tapCount: 0,
                         _tapTimer: null,
                         _singleTapTimer: null,
                         _suppressClickOnce: false,
                          // Mute arc state for circle mode
                          muteArcStart: null, // radians 0..2π
                          muteArcEnd: null,   // radians 0..2π
                          // Long-press detection
                          _lpTimer: null,
                          _lpMoved: false,
                          _lpTriggered: false,
                          _lpStart: { x: 0, y: 0 },
                         elements: {
                             widget: document.getElementById('music-visualizer-widget'),
                             canvas: document.getElementById('music-visualizer-canvas'),
                             overlay: document.getElementById('music-visualizer-overlay')
                         },
                         init() {
                             if (!this.elements.widget) return;
                             // Apply initial mode class
                             this.applyModeClass();
                              // Load persisted mute arc
                              try {
                                  const saved = JSON.parse(localStorage.getItem('musicVisualizerMuteArc'));
                                  if (saved && typeof saved.start === 'number' && typeof saved.end === 'number') {
                                      this.muteArcStart = this.normalizeAngle(saved.start);
                                      this.muteArcEnd = this.normalizeAngle(saved.end);
                                  }
                              } catch {}
                             // Click with delay to allow dblclick detection
                             this.elements.widget.addEventListener('click', (e) => {
                                 if (this.elements.widget.dataset.justDragged === 'true') return;
                                 if (this._suppressClickOnce) { this._suppressClickOnce = false; return; }
                                 clearTimeout(this._clickTimer);
                                 this._clickTimer = setTimeout(() => {
                                     // Always-on behavior: only start if not running; do not stop on click
                                     if (!this.stream) this.start();
                                 }, 250);
                             });
                             // Mouse double click toggles mode
                             this.elements.widget.addEventListener('dblclick', (e) => {
                                 e.preventDefault();
                                 clearTimeout(this._clickTimer);
                                 this.toggleMode();
                                 this._suppressClickOnce = true;
                             });
                             // Touch: single tap toggles mic immediately (for gesture compliance), double-tap toggles mode
                             this.elements.widget.addEventListener('touchstart', (e) => {
                                 if (e.touches.length !== 1) return;
                                 // mark to suppress synthetic click
                                 this._suppressClickOnce = true;
                                  // prepare long-press for arc marking (circle mode only)
                                  if (this.mode === 'circle') {
                                      const t = e.touches[0];
                                      this._lpStart = { x: t.clientX, y: t.clientY };
                                      this._lpMoved = false;
                                      this._lpTriggered = false;
                                      clearTimeout(this._lpTimer);
                                      this._lpTimer = setTimeout(() => {
                                          this._lpTriggered = true;
                                          this.handleLongPress(this._lpStart.x, this._lpStart.y);
                                      }, 600);
                                  }
                             }, { passive: true });
                              this.elements.widget.addEventListener('touchmove', (e) => {
                                  if (!this._lpTimer) return;
                                  const t = e.touches && e.touches[0];
                                  if (!t) return;
                                  const dx = t.clientX - this._lpStart.x;
                                  const dy = t.clientY - this._lpStart.y;
                                  if (Math.hypot(dx, dy) > 15) {
                                      this._lpMoved = true;
                                      clearTimeout(this._lpTimer);
                                      this._lpTimer = null;
                                  }
                              }, { passive: true });
                             this.elements.widget.addEventListener('touchend', (e) => {
                                  if (this._lpTimer) { clearTimeout(this._lpTimer); this._lpTimer = null; }
                                  if (this._lpTriggered) {
                                      // consume this gesture; do not treat as tap
                                      this._lpTriggered = false;
                                      this._tapCount = 0;
                                      e.preventDefault();
                                      return;
                                  }
                                  this._tapCount++;
                                 if (this._tapCount === 1) {
                                     // perform single-tap action immediately to keep user gesture
                                      if (this.elements.widget.dataset.justDragged !== 'true' && !this.stream) this.start();
                                     this._tapTimer = setTimeout(() => { this._tapCount = 0; }, 320);
                                 } else if (this._tapCount === 2) {
                                     clearTimeout(this._tapTimer);
                                     this._tapCount = 0;
                                     this.toggleMode();
                                 }
                                 e.preventDefault();
                             }, { passive: false });
                              // Mouse long-press for arc marking
                              this.elements.widget.addEventListener('mousedown', (e) => {
                                  if (e.button !== 0) return;
                                  if (this.mode !== 'circle') return;
                                  if (this.isMouseHeld) return; // resizing intent
                                  this._lpStart = { x: e.clientX, y: e.clientY };
                                  this._lpMoved = false;
                                  this._lpTriggered = false;
                                  const move = (ev) => {
                                      const dx = ev.clientX - this._lpStart.x;
                                      const dy = ev.clientY - this._lpStart.y;
                                      if (Math.hypot(dx, dy) > 8) {
                                          this._lpMoved = true;
                                          clearTimeout(this._lpTimer);
                                          this._lpTimer = null;
                                          cleanup();
                                      }
                                  };
                                  const up = () => { clearTimeout(this._lpTimer); this._lpTimer = null; cleanup(); };
                                  const cleanup = () => {
                                      document.removeEventListener('mousemove', move);
                                      document.removeEventListener('mouseup', up);
                                  };
                                  document.addEventListener('mousemove', move);
                                  document.addEventListener('mouseup', up, { once: true });
                                  clearTimeout(this._lpTimer);
                                  this._lpTimer = setTimeout(() => {
                                      this._lpTriggered = true;
                                      this.handleLongPress(this._lpStart.x, this._lpStart.y);
                                      cleanup();
                                  }, 600);
                              });
                             
                             window.addEventListener('resize', () => this.resizeCanvas(), { passive: true });
                             if ('ResizeObserver' in window) {
                                 const ro = new ResizeObserver(() => {
                                     // Ignore outer resize in circle mode to avoid fighting center resize
                                     if (this.mode !== 'circle') { this.resizeCanvas(); this.persistSize(); }
                                 });
                                     ro.observe(this.elements.widget);
                                 this._ro = ro;
                             }
                             // Mouse-hold + wheel to resize (both modes)
                             this.isMouseHeld = false;
                             this.elements.widget.addEventListener('mousedown', (e) => { if (e.button === 0) this.isMouseHeld = true; });
                             document.addEventListener('mouseup', () => { this.isMouseHeld = false; });
                             this.elements.widget.addEventListener('mouseleave', () => { this.isMouseHeld = false; });
                             this.elements.widget.addEventListener('wheel', (e) => {
                                 if (!this.isMouseHeld) return;
                                 e.preventDefault();
                                 const currentW = this.elements.widget.offsetWidth || 200;
                                 const currentH = this.elements.widget.offsetHeight || 200;
                                 const oldLeft = this.elements.widget.offsetLeft;
                                 const oldTop = this.elements.widget.offsetTop;
                                 const base = Math.min(currentW, currentH);
                                 const step = Math.max(8, Math.round(base * 0.08));
                                 const delta = e.deltaY < 0 ? step : -step;
                                 if (this.mode === 'circle') {
                                     const newSize = Math.max(80, Math.min(2000, base + delta));
                                     this.elements.widget.style.width = `${newSize}px`;
                                     this.elements.widget.style.height = `${newSize}px`;
                                     const dW = newSize - currentW;
                                     const dH = newSize - currentH;
                                     this.elements.widget.style.left = `${oldLeft - dW / 2}px`;
                                     this.elements.widget.style.top = `${oldTop - dH / 2}px`;
                                 } else {
                                     const newW = Math.max(120, Math.min(3000, currentW + delta));
                                     const newH = Math.max(90, Math.min(2000, currentH + delta));
                                     this.elements.widget.style.width = `${newW}px`;
                                     this.elements.widget.style.height = `${newH}px`;
                                     const dW = newW - currentW;
                                     const dH = newH - currentH;
                                     this.elements.widget.style.left = `${oldLeft - dW / 2}px`;
                                     this.elements.widget.style.top = `${oldTop - dH / 2}px`;
                                 }
                                 this.persistSize();
                                 this.resizeCanvas();
                             }, { passive: false });
                             this.resizeCanvas();
                         },
                         toggleMic() { if (!this.stream) { this.start(); } },
                         applyModeClass() {
                             this.elements.widget.classList.toggle('circle-mode', this.mode === 'circle');
                             // In circle mode, we handle resize with custom center box
                             if (this.mode === 'circle') {
                                 this.enableCenterResize();
                             } else {
                                 this.disableCenterResize();
                             }
                         },
                         toggleMode() {
                             this.mode = this.mode === 'circle' ? 'bars' : 'circle';
                             localStorage.setItem('musicVisualizerMode', this.mode);
                             this.applyModeClass();
                             if (this.mode === 'circle') {
                                 // Enforce square while keeping the visual center in place
                                 const w = this.elements.widget.offsetWidth || 200;
                                 const h = this.elements.widget.offsetHeight || 200;
                                 const oldLeft = this.elements.widget.offsetLeft;
                                 const oldTop = this.elements.widget.offsetTop;
                                 const size = Math.min(w, h);
                                 const dW = size - w;
                                 const dH = size - h;
                                 this.elements.widget.style.width = `${size}px`;
                                 this.elements.widget.style.height = `${size}px`;
                                 this.elements.widget.style.left = `${oldLeft - dW / 2}px`;
                                 this.elements.widget.style.top = `${oldTop - dH / 2}px`;
                                 this.persistSize();
                             }
                             this.resizeCanvas();
                         },
                         enableCenterResize() {
                             // No visible box; allow pinch on touch and wheel-resize while held (already implemented)
                             // Keep method for mode toggling compatibility
                         },
                         disableCenterResize() {
                             const box = document.getElementById('music-visualizer-resize-box');
                             if (box) box.style.display = 'none';
                             if (this._centerResizeCleanup) this._centerResizeCleanup();
                         },
                         resizeCanvas() {
                             const c = this.elements.canvas; if (!c) return;
                             const w = c.clientWidth, h = c.clientHeight;
                             if (w && h && (c.width !== w || c.height !== h)) { c.width = w; c.height = h; }
                         },
                         persistSize() {
                             try {
                                 const positions = JSON.parse(localStorage.getItem('lockscreenItemPositions_v5')) || {};
                                 const id = 'music-visualizer-widget';
                                 positions[id] = positions[id] || {};
                                 const widget = this.elements.widget;
                                 const lock = document.getElementById('lock-screen');
                                 positions[id].w = widget.style.width || widget.offsetWidth + 'px';
                                 positions[id].h = widget.style.height || widget.offsetHeight + 'px';
                                 if (lock && lock.clientWidth && lock.clientHeight) {
                                     positions[id].t = `${(widget.offsetTop / lock.clientHeight) * 100}%`;
                                     positions[id].l = `${(widget.offsetLeft / lock.clientWidth) * 100}%`;
                                 }
                                 localStorage.setItem('lockscreenItemPositions_v5', JSON.stringify(positions));
                             } catch {}
                         },
                         async start() {
                             if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                                 this.setOverlay('Microphone not available');
                                 return;
                             }
                             if (!window.isSecureContext) {
                                 this.setOverlay('Requires HTTPS');
                                 return;
                             }
                             try {
                                 this.stream = await navigator.mediaDevices.getUserMedia({
                                     audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: false }
                                 });
                                 this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                                 const source = this.audioCtx.createMediaStreamSource(this.stream);
                                 this.analyser = this.audioCtx.createAnalyser();
                                 this.analyser.fftSize = 1024;
                                 this.analyser.smoothingTimeConstant = 0.3; // more reactive for small sounds
                                 source.connect(this.analyser);
                                 this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                                 this.timeArray = new Uint8Array(this.analyser.fftSize);
                                 this.elements.overlay.style.display = 'none';
                                 this.draw();
                             } catch (err) {
                                 console.error('Mic error:', err);
                                 this.setOverlay('Mic blocked');
                                 this.stop(true);
                             }
                         },
                          draw() {
                             this.resizeCanvas();
                             const c = this.elements.canvas; const ctx = c.getContext('2d');
                             if (!this.analyser) return;
                             this.rafId = requestAnimationFrame(() => this.draw());
                             // Overall level from time-domain data for whole-widget reaction
                             this.analyser.getByteTimeDomainData(this.timeArray);
                             let sumSq = 0;
                             for (let i = 0; i < this.timeArray.length; i++) {
                                 const x = (this.timeArray[i] - 128) / 128;
                                 sumSq += x * x;
                             }
                             const rms = Math.sqrt(sumSq / this.timeArray.length);
                             const noiseFloor = 0.008; // lower floor to pick up small sounds
                             const linear = Math.max(0, (rms - noiseFloor) * 6.0);
                             const target = Math.min(1, Math.pow(linear, 0.7)); // compress to boost quiet parts
                             const k = target > this.level ? 0.7 : 0.12; // faster attack, slightly faster release
                             this.level += (target - this.level) * k;

                             // Use some frequency data just for texture
                             this.analyser.getByteFrequencyData(this.dataArray);
                             ctx.clearRect(0, 0, c.width, c.height);

                             if (this.mode === 'circle') {
                                 this.drawCircle(ctx, c.width, c.height);
                             } else {
                                 this.drawBars(ctx, c.width, c.height);
                             }
                         },
                          drawBars(ctx, width, height) {
                              // Background pulse to make whole widget react
                              const pulseAlpha = 0.06 + 0.20 * this.level;
                              ctx.fillStyle = `rgba(255,255,255,${pulseAlpha.toFixed(3)})`;
                              ctx.fillRect(0, 0, width, height);

                             const barCount = 60; // more bars for perceived sensitivity
                              const slice = Math.max(1, Math.floor(this.dataArray.length / barCount));
                              const barW = width / barCount;
                             const globalGain = 0.25 + 1.1 * this.level;
                              const time = performance.now() * 0.002;
                              for (let i = 0; i < barCount; i++) {
                                  const base = this.dataArray[i * slice] / 255;
                                 const wave = 0.35 * (0.5 + 0.5 * Math.sin(time + i * 0.5));
                                 const v = Math.min(1, base * 0.75 + wave * 0.9) * globalGain;
                                  const barH = v * height;
                                  ctx.fillStyle = 'rgba(255,255,255,1)';
                                  ctx.fillRect(i * barW, height - barH, barW - 2, barH);
                              }
                              const glow = Math.min(1, this.level * 2);
                              ctx.fillStyle = `rgba(255,255,255,${(0.08 + 0.22 * glow).toFixed(3)})`;
                              ctx.fillRect(0, 0, width, 3);
                              ctx.fillRect(0, height - 3, width, 3);
                          },
                          normalizeAngle(a) { let x = a % (Math.PI * 2); return x < 0 ? x + Math.PI * 2 : x; },
                          isAngleInArc(a, start, end) {
                              a = this.normalizeAngle(a); start = this.normalizeAngle(start); end = this.normalizeAngle(end);
                              if (start === end) return false;
                              if (end > start) return a >= start && a <= end;
                              // wrap-around case
                              return a >= start || a <= end;
                          },
                          isAngleMuted(a) {
                              if (typeof this.muteArcStart !== 'number' || typeof this.muteArcEnd !== 'number') return false;
                              return this.isAngleInArc(a, this.muteArcStart, this.muteArcEnd);
                          },
                          handleLongPress(clientX, clientY) {
                              // Map position to angle around the canvas center for alignment
                              const rect = this.elements.canvas.getBoundingClientRect();
                              const cx = rect.left + rect.width / 2;
                              const cy = rect.top + rect.height / 2;
                              // Angle 0 at +X axis; our radial bars are drawn outward from +X rotated by angle
                              const angle = this.normalizeAngle(Math.atan2(clientY - cy, clientX - cx));
                              // Sequence: set start -> set end -> clear both
                              if (typeof this.muteArcStart !== 'number') {
                                  this.muteArcStart = angle;
                                  this.persistMuteArc();
                                  this.flashOverlay('Start set');
                              } else if (typeof this.muteArcEnd !== 'number') {
                                  this.muteArcEnd = angle;
                                  // If end equals start, treat as cleared
                                  if (Math.abs(this.muteArcEnd - this.muteArcStart) < 0.01) { this.muteArcStart = null; this.muteArcEnd = null; }
                                  this.persistMuteArc();
                                  this.flashOverlay('End set');
                              } else {
                                  this.muteArcStart = null; this.muteArcEnd = null; this.persistMuteArc();
                                  this.flashOverlay('Mute arc cleared');
                              }
                          },
                          persistMuteArc() {
                              try {
                                  if (typeof this.muteArcStart === 'number' && typeof this.muteArcEnd === 'number') {
                                      localStorage.setItem('musicVisualizerMuteArc', JSON.stringify({ start: this.muteArcStart, end: this.muteArcEnd }));
                                  } else if (typeof this.muteArcStart === 'number' && typeof this.muteArcEnd !== 'number') {
                                      localStorage.setItem('musicVisualizerMuteArc', JSON.stringify({ start: this.muteArcStart, end: this.muteArcStart }));
                                  } else {
                                      localStorage.removeItem('musicVisualizerMuteArc');
                                  }
                              } catch {}
                          },
                          flashOverlay(text) {
                              const o = this.elements.overlay; if (!o) return;
                              const span = o.querySelector('span');
                              const prev = span ? span.textContent : '';
                              if (span) span.textContent = text;
                              const prevDisplay = o.style.display;
                              o.style.display = 'flex';
                              setTimeout(() => {
                                  if (span) span.textContent = prev || 'Tap to start';
                                  o.style.display = this.stream ? 'none' : 'flex';
                              }, 800);
                          },
                          drawCircle(ctx, width, height) {
                              const cx = width / 2, cy = height / 2;
                              const radius = Math.min(cx, cy) * 0.58;
                              const barCount = 80; // denser circle for small-sound response
                              const slice = Math.max(1, Math.floor(this.dataArray.length / barCount));
                              const time = performance.now() * 0.0025;
                              const globalGain = 0.3 + 1.3 * this.level;

                              // Soft pulsing center
                              ctx.beginPath();
                              ctx.arc(cx, cy, radius * (0.85 + 0.15 * this.level), 0, Math.PI * 2);
                              ctx.fillStyle = `rgba(255,255,255,${(0.05 + 0.15 * this.level).toFixed(3)})`;
                              ctx.fill();

                              // Radial spikes
                              ctx.save();
                              ctx.translate(cx, cy);
                              for (let i = 0; i < barCount; i++) {
                                  const angle = (i / barCount) * Math.PI * 2;
                                  if (this.isAngleMuted(angle)) continue;
                                  const base = this.dataArray[i * slice] / 255;
                                  const wave = 0.4 * (0.5 + 0.5 * Math.sin(time + i * 0.55));
                                  const v = Math.min(1, base * 0.8 + wave * 1.0) * globalGain;
                                  const barLen = v * radius;
                                  ctx.save();
                                  ctx.rotate(angle);
                                  ctx.fillStyle = 'rgba(255,255,255,1)';
                                  const w = Math.max(2, radius * 0.02);
                                  // Draw along +X axis (radial) instead of +Y to remove 90° offset
                                  ctx.fillRect(radius * 0.55, -w / 2, barLen, w);
                                  ctx.restore();
                              }
                              ctx.restore();

                              // Outer ring glow
                              const glowAlpha = 0.08 + 0.25 * this.level;
                              ctx.beginPath();
                              ctx.arc(cx, cy, radius * (1.55 + 0.15 * this.level), 0, Math.PI * 2);
                              ctx.strokeStyle = `rgba(255,255,255,${glowAlpha.toFixed(3)})`;
                              ctx.lineWidth = Math.max(2, radius * 0.03);
                              ctx.stroke();

                              // Draw muted arc overlay if defined
                              if (typeof this.muteArcStart === 'number' && typeof this.muteArcEnd === 'number' && this.muteArcStart !== this.muteArcEnd) {
                                  const outerR = radius * 1.6;
                                  const innerR = radius * 0.5;
                                  const s = this.normalizeAngle(this.muteArcStart);
                                  const e = this.normalizeAngle(this.muteArcEnd);
                                  const drawSegment = (a1, a2) => {
                                      ctx.beginPath();
                                      ctx.moveTo(cx + Math.cos(a1) * innerR, cy + Math.sin(a1) * innerR);
                                      ctx.arc(cx, cy, outerR, a1, a2, false);
                                      ctx.arc(cx, cy, innerR, a2, a1, true);
                                      ctx.closePath();
                                      ctx.fillStyle = 'rgba(255,255,255,0.08)';
                                      ctx.fill();
                                  };
                                  if (e > s) {
                                      drawSegment(s, e);
                                  } else {
                                      // wrap-around: split into two segments [s, 2π] and [0, e]
                                      drawSegment(s, Math.PI * 2);
                                      if (e > 0) drawSegment(0, e);
                                  }
                              }
                          },
                         setOverlay(text) {
                             this.elements.overlay.style.display = 'flex';
                             const span = this.elements.overlay.querySelector('span');
                             if (span) span.textContent = text;
                         },
                         stop(silent = false) {
                             if (this.rafId) cancelAnimationFrame(this.rafId);
                             this.rafId = null;
                             if (this.stream) { try { this.stream.getAudioTracks().forEach(t => t.stop()); } catch {} }
                             this.stream = null;
                             if (this.audioCtx) { try { this.audioCtx.close(); } catch {} }
                             this.audioCtx = null;
                             this.analyser = null;
                             const c = this.elements.canvas; const ctx = c.getContext('2d');
                             ctx.clearRect(0, 0, c.width, c.height);
                             if (!silent) this.setOverlay('Tap to start');
                         }
                     };
                     window.musicVisualizer = mv;
                     mv.init();
                    
                    // =================================================================
                    // CORRECTED WEBCAM WIDGET LOGIC
                    // =================================================================
                    
                    const webcamWidget = document.getElementById('webcam-widget');
                    const videoWrapper = webcamWidget.querySelector('.webcam-video-wrapper');
                    const canvasEl = webcamWidget.querySelector('#webcam-canvas');
                    const portraitBtn = document.getElementById('webcam-portrait-btn');
                    let isWebcamPortraitMode = false; // Renamed for clarity
                    let webcamPortraitBtnTimer = null;
                    let webcam_transform = { scale: 1, panX: 0, panY: 0 };
                    let webcamClickTimer = null;
                    let webcamGlowTimeout = null;
                    
                    const webcamPlayer = {
                        stream: null,
                        animationFrameId: null,
                        elements: {
                            widget: webcamWidget,
                            videoWrapper: videoWrapper,
                            video: webcamWidget.querySelector('#webcam-video-source'),
                            canvas: canvasEl,
                            canvasContext: canvasEl.getContext('2d'),
                            select: webcamWidget.querySelector('#webcam-source-select'),
                            stopBtn: webcamWidget.querySelector('#webcam-stop-btn'),
                            placeholder: webcamWidget.querySelector('#webcam-placeholder'),
                            toggleIcon: document.querySelector('#webcam-toggle-btn i'),
                        },
                        init() {
                            this.elements.widget.style.display = 'none';
                            this.elements.select.addEventListener('change', () => this.start());
                            this.elements.stopBtn.addEventListener('click', () => this.stop());
                            if (!this.elements.widget.classList.contains('hidden')) {
                                this.populateDevices();
                            }
                        },
                        drawToCanvas() {
                            if (!this.stream || !this.stream.active) return;
                            const video = this.elements.video;
                            const canvas = this.elements.canvas;
                            const ctx = this.elements.canvasContext;
                            
                            if (!video.videoWidth || !video.videoHeight) {
                                this.animationFrameId = requestAnimationFrame(() => this.drawToCanvas());
                                return;
                            }
                            
                            if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) {
                                canvas.width = canvas.clientWidth;
                                canvas.height = canvas.clientHeight;
                            }
                            if (canvas.width === 0 || canvas.height === 0) {
                                this.animationFrameId = requestAnimationFrame(() => this.drawToCanvas());
                                return;
                            }
                            
                            let vWidth = video.videoWidth, vHeight = video.videoHeight;
                            let sx = 0, sy = 0, sWidth = vWidth, sHeight = vHeight;
                            
                            if (isWebcamPortraitMode) {
                                // Portrait mode: crop to 9:16 ratio
                                const targetRatio = 9 / 16;
                                const videoRatio = vWidth / vHeight;
                                if (videoRatio > targetRatio) {
                                    sWidth = vHeight * targetRatio;
                                    sx = (vWidth - sWidth) / 2;
                                } else {
                                    sHeight = vWidth / targetRatio;
                                    sy = (vHeight - sHeight) / 2;
                                }
                            } else {
                                // Default mode: crop 20% from bottom to remove chin/desk area
                                sHeight = vHeight * 0.8;
                                sy = 0;
                            }

                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, canvas.width, canvas.height);
                            this.animationFrameId = requestAnimationFrame(() => this.drawToCanvas());
                        },
                        async populateDevices(shouldAutoload = false) {
                            try {
                                const devices = await navigator.mediaDevices.enumerateDevices();
                                const videoDevices = devices.filter(d => d.kind === 'videoinput');
                                const currentDeviceId = this.stream ? this.stream.getVideoTracks()[0].getSettings().deviceId : null;
                                this.elements.select.innerHTML = '';
                                if (videoDevices.length === 0) {
                                    this.elements.select.innerHTML = '<option value="">No cameras</option>';
                                    this.stop();
                                    return;
                                }
                                videoDevices.forEach((device) => {
                                    const option = document.createElement('option');
                                    option.value = device.deviceId;
                                    option.textContent = device.label || `Camera ${videoDevices.indexOf(device) + 1}`;
                                    this.elements.select.appendChild(option);
                                });
                                if (currentDeviceId && this.elements.select.querySelector(`option[value="${currentDeviceId}"]`)) {
                                    this.elements.select.value = currentDeviceId;
                                }
                                if (shouldAutoload && !this.stream && videoDevices.length > 0) {
                                    this.elements.select.value = videoDevices[0].deviceId;
                                    this.start();
                                }
                            } catch (err) {
                                console.error("Error enumerating devices:", err);
                                this.elements.placeholder.querySelector('span').textContent = "Device Error";
                            }
                        },
                        async start() {
                            if (this.stream) {
                                if (this.stream.getVideoTracks()[0].getSettings().deviceId === this.elements.select.value) return;
                                this.stop(true);
                            }
                            this.elements.widget.classList.remove('hidden');
                            const webcamToggleBtn = document.getElementById('webcam-toggle-btn');
                            if (webcamToggleBtn) webcamToggleBtn.classList.remove('hidden');
                            this.elements.widget.style.display = 'flex';
                            const deviceId = this.elements.select.value;
                            if (!deviceId) { this.stop(); return; }
                            const constraints = { video: { deviceId: { exact: deviceId }, width: { ideal: 1280 }, height: { ideal: 720 } } };
                            try {
                                this.stream = await navigator.mediaDevices.getUserMedia(constraints);
                                this.elements.video.srcObject = this.stream;
                                this.elements.video.onloadedmetadata = () => {
                                    this.elements.video.play();
                                    this.elements.widget.classList.add('active');
                                    if (this.elements.toggleIcon) this.elements.toggleIcon.className = 'fa-solid fa-video';
                                    this.drawToCanvas();
                                };
                                this.populateDevices(false);
                            } catch (err) {
                                console.error(`Error starting camera:`, err);
                                this.elements.widget.classList.remove('active');
                                this.elements.placeholder.querySelector('span').textContent = "Access Denied";
                                this.stop();
                            }
                        },
                        stop(isRestarting = false) {
                            if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
                            this.animationFrameId = null;
                            if (this.stream) this.stream.getTracks().forEach(track => track.stop());
                            this.stream = null;
                            this.elements.video.srcObject = null;
                            if (this.elements.canvasContext) this.elements.canvasContext.clearRect(0, 0, this.elements.canvas.width, this.elements.canvas.height);
                            this.elements.widget.classList.remove('active');
                            if (this.elements.toggleIcon) this.elements.toggleIcon.className = 'fa-solid fa-video-slash';
                            if (!isRestarting) this.elements.widget.style.display = 'none';
                        },
                                            savePanZoomState() { localStorage.setItem('webcamPanZoomState', JSON.stringify(webcam_transform)); },
                    loadPanZoomState() {
                        const state = localStorage.getItem('webcamPanZoomState');
                        if (state) {
                            try {
                                const obj = JSON.parse(state);
                                if (typeof obj.scale === 'number' && typeof obj.panX === 'number' && typeof obj.panY === 'number') {
                                    webcam_transform = obj;
                                    applyWebcamTransform();
                                }
                            } catch {}
                        }
                    },
                    saveAllWebcamState() {
                        const state = {
                            position: {
                                top: webcamWidget.style.top || webcamWidget.offsetTop + 'px',
                                left: webcamWidget.style.left || webcamWidget.offsetLeft + 'px'
                            },
                            size: {
                                width: webcamWidget.style.width || webcamWidget.offsetWidth + 'px',
                                height: webcamWidget.style.height || webcamWidget.offsetHeight + 'px'
                            },
                            portraitMode: isWebcamPortraitMode,
                            panZoom: webcam_transform
                        };
                        localStorage.setItem('webcamFullState', JSON.stringify(state));
                    },
                    loadAllWebcamState() {
                        const state = localStorage.getItem('webcamFullState');
                        if (state) {
                            try {
                                const obj = JSON.parse(state);
                                
                                // Restore position
                                if (obj.position) {
                                    webcamWidget.style.top = obj.position.top;
                                    webcamWidget.style.left = obj.position.left;
                                }
                                
                                // Restore size
                                if (obj.size) {
                                    webcamWidget.style.width = obj.size.width;
                                    webcamWidget.style.height = obj.size.height;
                                }
                                
                                // Restore portrait mode
                                if (typeof obj.portraitMode === 'boolean') {
                                    isWebcamPortraitMode = obj.portraitMode;
                                    if (portraitBtn) {
                                        portraitBtn.textContent = isWebcamPortraitMode ? 'Full' : '9:16';
                                    }
                                }
                                
                                // Restore pan/zoom
                                if (obj.panZoom && typeof obj.panZoom.scale === 'number') {
                                    webcam_transform = obj.panZoom;
                                    applyWebcamTransform();
                                }
                            } catch {}
                        }
                    }
                    };
                    window.webcamPlayer = webcamPlayer;
                    webcamPlayer.init();
                    
                    // Load saved state when page loads
                    webcamPlayer.loadAllWebcamState();

                    function applyWebcamTransform() {
                        canvasEl.style.transform = `translate(${webcam_transform.panX}px, ${webcam_transform.panY}px) scale(${webcam_transform.scale})`;
                        updateWebcamCursor();
                    }
                    
                    function updateWebcamCursor() {
                        if (window.isWebcamPanZoomMode) {
                            if (webcam_transform.scale > 1) {
                                videoWrapper.style.cursor = 'grab';
                            } else {
                                videoWrapper.style.cursor = 'zoom-in';
                            }
                        }
                    }

                    function updatePortraitBtnPosition() {
                        const rect = webcamWidget.getBoundingClientRect();
                        const left = rect.left + (rect.width / 2) - (portraitBtn.offsetWidth / 2);
                        const top = rect.bottom + 10;
                        portraitBtn.style.left = `${left}px`;
                        portraitBtn.style.top = `${top}px`;
                    }

                    function showPortraitBtn() {
                        updatePortraitBtnPosition();
                        portraitBtn.style.opacity = '1';
                        portraitBtn.style.pointerEvents = 'auto';
                        clearTimeout(webcamPortraitBtnTimer);
                        webcamPortraitBtnTimer = setTimeout(hidePortraitBtn, 10000);
                    }

                    function hidePortraitBtn() {
                        portraitBtn.style.opacity = '0';
                        portraitBtn.style.pointerEvents = 'none';
                    }

                    function updatePortraitBtnVisibility() {
                        if (window.isWebcamPanZoomMode) {
                            showPortraitBtn();
                        } else {
                            hidePortraitBtn();
                        }
                    }

                    function toggleWebcamPanZoomMode() {
                        window.isWebcamPanZoomMode = !window.isWebcamPanZoomMode;
                        webcamWidget.classList.toggle('webcam-pan-zoom-active', window.isWebcamPanZoomMode);
                        if (window.isWebcamPanZoomMode) {
                            webcamPlayer.loadPanZoomState();
                            clearTimeout(webcamGlowTimeout);
                            webcamGlowTimeout = setTimeout(() => {
                                webcamWidget.classList.remove('webcam-pan-zoom-active');
                                window.isWebcamPanZoomMode = false;
                                updatePortraitBtnVisibility();
                            }, 15000);
                        } else {
                            clearTimeout(webcamGlowTimeout);
                        }
                        updatePortraitBtnVisibility();
                        updateWebcamCursor();
                    }

                    // --- IMPROVED DOUBLE-CLICK/TAP TO ENTER/EXIT MODE ---
                    let webcamTapCount = 0;
                    let webcamTapTimer = null;
                    
                    // Mouse double-click
                    webcamWidget.addEventListener('dblclick', (e) => {
                        if (e.target.closest('#webcam-controls, #webcam-portrait-btn')) return;
                        e.preventDefault();
                        e.stopPropagation();
                        toggleWebcamPanZoomMode();
                    });

                    // Improved touch double-tap detection
                    webcamWidget.addEventListener('touchstart', (e) => {
                        if (e.target.closest('#webcam-controls, #webcam-portrait-btn')) return;
                        if (e.touches.length !== 1) return; // Only single finger taps
                        
                        webcamTapCount++;
                        
                        if (webcamTapCount === 1) {
                            webcamTapTimer = setTimeout(() => {
                                webcamTapCount = 0; // Reset if second tap doesn't come
                            }, 400); // 400ms window for double tap
                        } else if (webcamTapCount === 2) {
                            clearTimeout(webcamTapTimer);
                            webcamTapCount = 0;
                            e.preventDefault();
                            e.stopPropagation();
                            toggleWebcamPanZoomMode();
                        }
                    });

                    let resizeGestureState = {}; // Declare here for use in touchend handler
                    
                    webcamWidget.addEventListener('touchend', (e) => {
                        if (e.target.closest('#webcam-controls, #webcam-portrait-btn')) return;
                        
                        // Handle pinch resize end
                        if (e.touches.length < 2) {
                            resizeGestureState = {};
                        }
                    });

                    portraitBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        isWebcamPortraitMode = !isWebcamPortraitMode;
                        
                        // Resize the webcam widget based on mode
                        const currentWidth = webcamWidget.offsetWidth;
                        if (isWebcamPortraitMode) {
                            // Switch to portrait: make it narrower and taller
                            const newWidth = Math.round(currentWidth * 0.6);
                            webcamWidget.style.width = `${newWidth}px`;
                            webcamWidget.style.height = `${Math.round(newWidth * 16 / 9)}px`;
                        } else {
                            // Switch back to landscape: make it wider and shorter  
                            const newWidth = Math.round(currentWidth * 1.67);
                            webcamWidget.style.width = `${newWidth}px`;
                            webcamWidget.style.height = `${Math.round(newWidth * 9 / 16)}px`;
                        }
                        
                        // Recalculate and clamp pan position after resize
                        setTimeout(() => {
                            if (webcam_transform.scale > 1) {
                                const rect = videoWrapper.getBoundingClientRect();
                                const max_panX = (rect.width * webcam_transform.scale - rect.width) / 2;
                                const max_panY = (rect.height * webcam_transform.scale - rect.height) / 2;
                                webcam_transform.panX = Math.max(-max_panX, Math.min(max_panX, webcam_transform.panX));
                                webcam_transform.panY = Math.max(-max_panY, Math.min(max_panY, webcam_transform.panY));
                                applyWebcamTransform();
                                webcamPlayer.savePanZoomState();
                            }
                        }, 10); // Small delay to let resize complete
                        
                        portraitBtn.textContent = isWebcamPortraitMode ? 'Full' : '9:16';
                        showPortraitBtn(); // Reset the hide timer
                        
                        // Save all webcam state after portrait change
                        webcamPlayer.saveAllWebcamState();
                    });

                    // Watch for any manual size changes and correct aspect ratio
                    const observer = new MutationObserver((mutations) => {
                        updatePortraitBtnPosition();
                        
                        // Check if size was changed manually and correct aspect ratio
                        mutations.forEach(mutation => {
                            if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
                                setTimeout(() => {
                                    const currentWidth = webcamWidget.offsetWidth;
                                    const currentHeight = webcamWidget.offsetHeight;
                                    let correctHeight;
                                    
                                    if (isWebcamPortraitMode) {
                                        // Portrait mode: should be 9:16 ratio (taller)
                                        correctHeight = Math.round(currentWidth * 16 / 9);
                                    } else {
                                        // Landscape mode: should be 16:9 ratio (wider)
                                        correctHeight = Math.round(currentWidth * 9 / 16);
                                    }
                                    
                                    // Only adjust if significantly different (avoid infinite loops)
                                    if (Math.abs(currentHeight - correctHeight) > 5) {
                                        webcamWidget.style.height = `${correctHeight}px`;
                                        // Save state after size correction
                                        setTimeout(() => webcamPlayer.saveAllWebcamState(), 100);
                                    }
                                }, 0);
                            }
                        });
                    });
                    observer.observe(webcamWidget, { attributes: true, attributeFilter: ['style', 'class'] });

                    // The rest of the pan/zoom logic remains the same
                    // It correctly listens on videoWrapper, canvasEl, and document for gestures.
                    const get_touch_dist = (t) => Math.hypot(t[0].clientX - t[1].clientX, t[0].clientY - t[1].clientY);
                    let webcamPanMouse = { isDown: false, startX: 0, startY: 0, startPanX: 0, startPanY: 0 };
                    let webcamWidgetDragInProgress = false;
                    
                    // Long press for mirror toggle (removed single click)
                    let webcamLongPressTimer = null;
                    let webcamLongPressStarted = false;
                    
                    function startWebcamLongPress(e) {
                        if (window.isWebcamPanZoomMode || webcamWidgetDragInProgress || webcam_transform.scale > 1) return;
                        webcamLongPressStarted = true;
                        webcamLongPressTimer = setTimeout(() => {
                            if (webcamLongPressStarted) {
                                videoWrapper.classList.toggle('normal-view');
                                // Brief visual feedback
                                videoWrapper.style.filter = 'brightness(1.3)';
                                setTimeout(() => videoWrapper.style.filter = '', 150);
                            }
                        }, 500); // 500ms long press
                    }
                    
                    function cancelWebcamLongPress() {
                        webcamLongPressStarted = false;
                        if (webcamLongPressTimer) {
                            clearTimeout(webcamLongPressTimer);
                            webcamLongPressTimer = null;
                        }
                    }
                    
                    videoWrapper.addEventListener('mousedown', startWebcamLongPress);
                    videoWrapper.addEventListener('mouseup', cancelWebcamLongPress);
                    videoWrapper.addEventListener('mousemove', cancelWebcamLongPress);
                    videoWrapper.addEventListener('mouseleave', cancelWebcamLongPress);
                    videoWrapper.addEventListener('touchstart', startWebcamLongPress);
                    videoWrapper.addEventListener('touchmove', cancelWebcamLongPress, { passive: true });
                    videoWrapper.addEventListener('touchend', cancelWebcamLongPress);
                    videoWrapper.addEventListener('touchcancel', cancelWebcamLongPress);
                    
                    videoWrapper.addEventListener('wheel', (e) => {
                        if (!window.isWebcamPanZoomMode) return;
                        e.preventDefault();
                        let scale = webcam_transform.scale * (e.deltaY < 0 ? 1.08 : 1 / 1.08);
                        webcam_transform.scale = Math.max(1, Math.min(5, scale));
                        
                        // Apply bounds checking after zoom and reset pan if zoomed fully out
                        if (webcam_transform.scale > 1) {
                            const rect = videoWrapper.getBoundingClientRect();
                            const max_panX = (rect.width * webcam_transform.scale - rect.width) / 2;
                            const max_panY = (rect.height * webcam_transform.scale - rect.height) / 2;
                            webcam_transform.panX = Math.max(-max_panX, Math.min(max_panX, webcam_transform.panX));
                            webcam_transform.panY = Math.max(-max_panY, Math.min(max_panY, webcam_transform.panY));
                        } else {
                            // Reset pan position when fully zoomed out
                            webcam_transform.panX = 0;
                            webcam_transform.panY = 0;
                        }
                        
                        applyWebcamTransform();
                        webcamPlayer.savePanZoomState();
                    }, { passive: false });
                    
                    webcamWidget.addEventListener('mousedown', (e) => {
                        if (window.isWebcamPanZoomMode) return; // Don't stop propagation - let videoWrapper handle it
                        webcamWidgetDragInProgress = false;
                        const sX = e.clientX, sY = e.clientY;
                        const move = () => webcamWidgetDragInProgress = true;
                        const up = () => {
                            document.removeEventListener('mousemove', move);
                            document.removeEventListener('mouseup', up);
                        };
                        document.addEventListener('mousemove', move, { once: true });
                        document.addEventListener('mouseup', up, { once: true });
                    }, true);

                    // Pinch resize when NOT in zoom mode
                    webcamWidget.addEventListener('touchstart', (e) => {
                        if (window.isWebcamPanZoomMode) return; // Only when NOT in zoom mode
                        if (e.touches.length === 2) {
                            e.preventDefault();
                            e.stopPropagation();
                            resizeGestureState.initialDist = get_touch_dist(e.touches);
                            resizeGestureState.initialWidth = webcamWidget.offsetWidth;
                        }
                    }, { passive: false });
                    
                    webcamWidget.addEventListener('touchmove', (e) => {
                        if (window.isWebcamPanZoomMode || !resizeGestureState.initialDist) return;
                        if (e.touches.length === 2) {
                            e.preventDefault();
                            const currentDist = get_touch_dist(e.touches);
                            const scaleRatio = currentDist / resizeGestureState.initialDist;
                            let newWidth = Math.max(120, Math.min(800, resizeGestureState.initialWidth * scaleRatio));
                            webcamWidget.style.width = `${Math.round(newWidth)}px`;
                            // Use correct aspect ratio based on current mode
                            if (isWebcamPortraitMode) {
                                // Portrait mode: 9:16 ratio (taller)
                                webcamWidget.style.height = `${Math.round(newWidth * 16 / 9)}px`;
                            } else {
                                // Landscape mode: 16:9 ratio (wider)
                                webcamWidget.style.height = `${Math.round(newWidth * 9 / 16)}px`;
                            }
                            // Save state after pinch resize
                            webcamPlayer.saveAllWebcamState();
                        }
                    }, { passive: false });
                    


                    // Pan/zoom mode touch gestures (only when in zoom mode)
                    let touchGestureState = {};
                    videoWrapper.addEventListener('touchstart', (e) => {
                        if (!window.isWebcamPanZoomMode) return;
                        cancelWebcamLongPress(); // Cancel any ongoing long press
                        e.stopPropagation();
                        touchGestureState.startTransform = { ...webcam_transform };
                        if (e.touches.length === 1) {
                            touchGestureState.startTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                        } else if (e.touches.length === 2) {
                            touchGestureState.initialPinchDist = get_touch_dist(e.touches);
                        }
                    }, { passive: false });

                    videoWrapper.addEventListener('touchmove', (e) => {
                        if (!window.isWebcamPanZoomMode || !touchGestureState.startTransform) return;
                        e.preventDefault();
                        e.stopPropagation();
                        if (e.touches.length === 2 && touchGestureState.initialPinchDist) {
                            webcam_transform.scale = Math.max(1.0, touchGestureState.startTransform.scale * (get_touch_dist(e.touches) / touchGestureState.initialPinchDist));
                        } else if (e.touches.length === 1 && touchGestureState.startTouch && webcam_transform.scale > 1) {
                            const dx = e.touches[0].clientX - touchGestureState.startTouch.x;
                            const dy = e.touches[0].clientY - touchGestureState.startTouch.y;
                            
                            // Reverse X direction when mirrored (not normal-view)
                            const isMirrored = !videoWrapper.classList.contains('normal-view');
                            const adjustedDx = isMirrored ? -dx : dx;
                            
                            webcam_transform.panX = touchGestureState.startTransform.panX + adjustedDx;
                            webcam_transform.panY = touchGestureState.startTransform.panY + dy;
                        }
                        // Apply bounds checking when zoomed in
                        if (webcam_transform.scale > 1) {
                            const rect = videoWrapper.getBoundingClientRect();
                            const max_panX = (rect.width * webcam_transform.scale - rect.width) / 2;
                            const max_panY = (rect.height * webcam_transform.scale - rect.height) / 2;
                            webcam_transform.panX = Math.max(-max_panX, Math.min(max_panX, webcam_transform.panX));
                            webcam_transform.panY = Math.max(-max_panY, Math.min(max_panY, webcam_transform.panY));
                        }
                        applyWebcamTransform();
                    }, { passive: false });

                    videoWrapper.addEventListener('touchend', () => {
                        if (!window.isWebcamPanZoomMode) return;
                        if(touchGestureState.startTransform) webcamPlayer.savePanZoomState();
                        touchGestureState = {};
                    });

                    // Mouse panning on videoWrapper instead of canvas
                    videoWrapper.addEventListener('mousedown', (e) => {
                        if (!window.isWebcamPanZoomMode || webcam_transform.scale <= 1) return; // Only when zoomed in
                        cancelWebcamLongPress(); // Cancel any ongoing long press
                        e.preventDefault();
                        e.stopPropagation();
                        webcamPanMouse = { isDown: true, startX: e.clientX, startY: e.clientY, startPanX: webcam_transform.panX, startPanY: webcam_transform.panY };
                        videoWrapper.classList.add('panning'); // Show grabbing cursor
                        document.addEventListener('mousemove', webcamPanMouseMove);
                        document.addEventListener('mouseup', webcamPanMouseUp, { once: true });
                    });

                    function webcamPanMouseMove(e) {
                        if (!webcamPanMouse.isDown || webcam_transform.scale <= 1) return; // Don't pan when not zoomed
                        
                        const deltaX = e.clientX - webcamPanMouse.startX;
                        const deltaY = e.clientY - webcamPanMouse.startY;
                        
                        // Reverse X direction when mirrored (not normal-view)
                        const isMirrored = !videoWrapper.classList.contains('normal-view');
                        const adjustedDeltaX = isMirrored ? -deltaX : deltaX;
                        
                        webcam_transform.panX = webcamPanMouse.startPanX + adjustedDeltaX;
                        webcam_transform.panY = webcamPanMouse.startPanY + deltaY;
                        
                        // Apply bounds checking to keep within visible area
                        const rect = videoWrapper.getBoundingClientRect();
                        const max_panX = (rect.width * webcam_transform.scale - rect.width) / 2;
                        const max_panY = (rect.height * webcam_transform.scale - rect.height) / 2;
                        webcam_transform.panX = Math.max(-max_panX, Math.min(max_panX, webcam_transform.panX));
                        webcam_transform.panY = Math.max(-max_panY, Math.min(max_panY, webcam_transform.panY));
                        
                        applyWebcamTransform();
                    }

                    function webcamPanMouseUp() {
                        if (webcamPanMouse.isDown) {
                            webcamPanMouse.isDown = false;
                            videoWrapper.classList.remove('panning'); // Remove grabbing cursor
                            webcamPlayer.savePanZoomState();
                            document.removeEventListener('mousemove', webcamPanMouseMove);
                        }
                    }
                })();
                
                (function setupBaseFeatures() {
                    const webcamToggleBtn = document.getElementById('webcam-toggle-btn');
                    const DRAGGABLE_ELEMENT_IDS = ['clock', 'youtube-music-btn', 'youtube-btn', 'stock-widget', 'settings-btn', 'fun-stock-name-display', 'note-widget', 'music-widget', 'music-visualizer-widget', 'gif-widget', 'webcam-widget', 'webcam-toggle-btn'];
                    const WIDGETS = {
                        stock: { el: document.getElementById('stock-widget'), toggle: document.getElementById('toggle-stock-widget'), default: true },
                        note: { el: document.getElementById('note-widget'), toggle: document.getElementById('toggle-note-widget'), default: false },
                        music: { el: document.getElementById('music-widget'), toggle: document.getElementById('toggle-music-widget'), default: false },
                        musicVisualizer: { el: document.getElementById('music-visualizer-widget'), toggle: document.getElementById('toggle-music-visualizer-widget'), default: false },
                        gif: { el: document.getElementById('gif-widget'), toggle: document.getElementById('toggle-gif-widget'), default: false },
                        webcam: { el: document.getElementById('webcam-widget'), toggle: document.getElementById('toggle-webcam-widget'), default: false },
                    };
                    
                    function initializeWidgetToggles() {
                        for(const key in WIDGETS) {
                            const widget = WIDGETS[key];
                            const savedState = localStorage.getItem(`widget_${key}_visible`);
                            const isVisible = savedState === null ? widget.default : savedState === 'true';
                            
                            widget.el.classList.toggle('hidden', !isVisible);
                            widget.toggle.checked = isVisible;

                            if (key === 'webcam') {
                                webcamToggleBtn.classList.toggle('hidden', !isVisible);
                                if (isVisible && document.getElementById('toggle-webcam-widget').checked) {
                                    window.webcamPlayer.populateDevices();
                                }
                            }
                            if (key === 'musicVisualizer' && !isVisible) {
                                if (window.musicVisualizer) window.musicVisualizer.stop(true);
                            }

                            widget.toggle.addEventListener('change', () => {
                                const isChecked = widget.toggle.checked;
                                widget.el.classList.toggle('hidden', !isChecked);
                                localStorage.setItem(`widget_${key}_visible`, isChecked);

                                if (key === 'webcam') {
                                    webcamToggleBtn.classList.toggle('hidden', !isChecked);
                                    if (isChecked) {
                                        window.webcamPlayer.populateDevices();
                                    } else {
                                        window.webcamPlayer.stop();
                                    }
                                }
                                if (key === 'musicVisualizer' && !isChecked) {
                                    if (window.musicVisualizer) window.musicVisualizer.stop();
                                }
                            });
                        }
                    }
                    initializeWidgetToggles();
                    webcamToggleBtn.addEventListener('click', (e) => {
                        const btn = e.currentTarget;
                        if (btn.dataset.justDragged === 'true') return;
                        if (window.webcamPlayer.stream) {
                            window.webcamPlayer.stop();
                        } else {
                            window.webcamPlayer.start();
                        }
                    });

                    const timeElems = { h: document.getElementById('hours'), m: document.getElementById('minutes'), d: document.getElementById('date') };
                    const weatherElems = { t: document.getElementById('temperature'), i: document.getElementById('weather-icon') };
                    const weatherLocationInput = document.getElementById('weather-location-input');
                    let clockScale = 1;
                    const getWeatherLocation = () => localStorage.getItem('lockscreenWeatherLocation') || '';
                    const fetchWeather = () => {
                        const location = getWeatherLocation();
                        weatherLocationInput.value = location;
                        const url = `https://wttr.in/${location || 'Trondheim'}?format=j1`;
                        const iM = { 'sunny': 'fa-sun', 'clear': 'fa-sun', 'partly cloudy': 'fa-cloud-sun', 'cloudy': 'fa-cloud', 'overcast': 'fa-cloud', 'mist': 'fa-smog', 'fog': 'fa-smog', 'patchy rain': 'fa-cloud-rain', 'rain': 'fa-cloud-showers-heavy', 'drizzle': 'fa-cloud-rain', 'patchy snow': 'fa-snowflake', 'snow': 'fa-snowflake', 'sleet': 'fa-cloud-meatball', 'ice pellets': 'fa-icicles', 'thunder': 'fa-cloud-bolt', 'blizzard': 'fa-wind' };
                        fetch(url).then(r => r.json()).then(d => { const c = d.current_condition[0]; weatherElems.t.textContent = `${c.temp_C}°C`; const ds = c.weatherDesc[0].value.toLowerCase(); let ic = 'fa-cloud-sun'; for (const k in iM) { if (ds.includes(k)) { ic = iM[k]; break; } } weatherElems.i.className = `fa-solid ${ic}`; }).catch(e => { weatherElems.t.textContent = 'N/A'; });
                    };
                    weatherLocationInput.addEventListener('change', () => { localStorage.setItem('lockscreenWeatherLocation', weatherLocationInput.value.trim()); fetchWeather(); });
                    const updateTime = () => { const n = new Date(); timeElems.h.textContent = String(n.getHours()).padStart(2, '0'); timeElems.m.textContent = String(n.getMinutes()).padStart(2, '0'); timeElems.d.textContent = n.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' }); };
                    const applyClockScale = (scale) => { const baseSizeVW = 15; const newSize = baseSizeVW * scale; timeElems.h.style.fontSize = `clamp(${newSize * 0.4}rem, ${newSize}vw, ${newSize * 0.8}rem)`; timeElems.m.style.fontSize = `clamp(${newSize * 0.4}rem, ${newSize}vw, ${newSize * 0.8}rem)`; clockScale = scale; };
                    
                        const savePos = () => {
                        const p = {};
                        DRAGGABLE_ELEMENT_IDS.forEach(id => {
                            const e = document.getElementById(id);
                            if (e) {
                                p[id] = { t: `${(e.offsetTop / lockScreen.clientHeight) * 100}%`, l: `${(e.offsetLeft / lockScreen.clientWidth) * 100}%` };
                                if (id === 'clock') p[id].s = clockScale;
                                    if (id === 'note-widget' || id === 'gif-widget' || id === 'webcam-widget' || id === 'music-visualizer-widget') {
                                        // Allow sizes to exceed viewport, so read actual pixels if style is empty
                                        const w = e.style.width || (e.offsetWidth + 'px');
                                        const h = e.style.height || (e.offsetHeight + 'px');
                                        p[id].w = w; p[id].h = h;
                                    }
                            }
                        });
                        localStorage.setItem('lockscreenItemPositions_v5', JSON.stringify(p));
                    };
                    const loadPos = () => {
                        const p = JSON.parse(localStorage.getItem('lockscreenItemPositions_v5'));
                        if (p) {
                            Object.keys(p).forEach(id => {
                                const e = document.getElementById(id);
                                const pos = p[id];
                                if (e && pos.t && pos.l) {
                                    e.style.top = pos.t; e.style.left = pos.l;
                                    e.style.transform = (id === 'clock' || id === 'stock-widget') ? 'none' : e.style.transform;
                                    if (id === 'clock' && pos.s) applyClockScale(pos.s);
                                    if (id === 'note-widget' || id === 'gif-widget' || id === 'webcam-widget' || id === 'music-visualizer-widget') { e.style.width = pos.w || e.style.width; e.style.height = pos.h || e.style.height; }
                                }
                            });
                        }
                    };
                    
                    const makeDraggable = (el) => {
                        let oX, oY, isD, hasMoved;
                        let isPinching = false, initialPinchDist, initialScale;
                        const getDist = (t) => Math.hypot(t[0].clientX - t[1].clientX, t[0].clientY - t[1].clientY);
                        
                        const mv = (e) => {
                            if (el.isEditing) return;
                            if (el.id === 'clock' && isPinching && e.touches && e.touches.length === 2) {
                                e.preventDefault();
                                const oldWidth = el.offsetWidth, oldHeight = el.offsetHeight, oldLeft = el.offsetLeft, oldTop = el.offsetTop;
                                const newDist = getDist(e.touches); const scaleRatio = newDist / initialPinchDist; const newScale = Math.max(0.5, Math.min(initialScale * scaleRatio, 3));
                                applyClockScale(newScale); const newWidth = el.offsetWidth, newHeight = el.offsetHeight; const deltaWidth = newWidth - oldWidth, deltaHeight = newHeight - oldHeight;
                                el.style.left = `${oldLeft - (deltaWidth / 2)}px`; el.style.top = `${oldTop - (deltaHeight / 2)}px`; return;
                            }
                            if (!isD) return; 
                            // Prevent accidental dragging while resizing via mouse-hold + wheel on the music visualizer
                            if (el.id === 'music-visualizer-widget' && window.musicVisualizer && window.musicVisualizer.isMouseHeld) {
                                return;
                            }
                            e.preventDefault(); 
                            hasMoved = true;
                            
                            let cX, cY;
                            if (e.touches && e.touches.length > 0) {
                                cX = e.touches[0].clientX;
                                cY = e.touches[0].clientY;
                            } else {
                                cX = e.clientX;
                                cY = e.clientY;
                            }
                            
                            let nX = cX - oX, nY = cY - oY;
                            const sR = lockScreen;
                            // Slightly relaxed bounds during drag to ease large-size placement
                            const maxX = sR.clientWidth - el.offsetWidth + 100;
                            const maxY = sR.clientHeight - el.offsetHeight + 100;
                            const minX = -100;
                            const minY = -100;
                            nX = Math.max(minX, Math.min(nX, maxX));
                            nY = Math.max(minY, Math.min(nY, maxY));
                            // Allow moving outside screen bounds slightly for large widgets
                            el.style.left = `${nX}px`; 
                            el.style.top = `${nY}px`;
                            if(['clock', 'stock-widget'].indexOf(el.id) === -1) el.style.transform = 'none';
                        };
                        
                        const stD = (e) => {
                            if (!isD && !isPinching) return;
                            // Mark on element instead of event target
                            el.dataset.justDragged = hasMoved ? 'true' : 'false';
                            if (el.id === 'fun-stock-name-display' && el.classList.contains('visible')) { 
                                stockNameFadeOutTimer = setTimeout(() => { el.classList.remove('visible'); }, 3000); 
                            }
                            isD = false; 
                            isPinching = false;
                            if (hasMoved) {
                                savePos();
                                // Also save webcam-specific state if it was the webcam widget that moved
                                if (el.id === 'webcam-widget') {
                                    setTimeout(() => webcamPlayer.saveAllWebcamState(), 50);
                                }
                            }
                            document.removeEventListener('mousemove', mv); 
                            document.removeEventListener('touchmove', mv);
                        };
                        
                        const sD_longPress = (e) => {
                            if (el.id === 'webcam-widget' && window.isWebcamPanZoomMode) {
                                return;
                            }
                            if (el.isEditing) return;
                            if (e.target.closest('#music-controls, #remove-gif-btn, #webcam-controls, #note-settings-btn, #webcam-portrait-btn')) return;
                            if (e.touches && e.touches.length === 2 && el.id === 'clock') { 
                                isPinching = true; 
                                isD = false; 
                                initialPinchDist = getDist(e.touches); 
                                initialScale = clockScale; 
                                return; 
                            }
                            
                            isD = true; 
                            hasMoved = false; 
                            el.dataset.justDragged = 'false';
                            
                            let cX, cY;
                            if (e.touches && e.touches.length > 0) {
                                cX = e.touches[0].clientX;
                                cY = e.touches[0].clientY;
                            } else {
                                cX = e.clientX;
                                cY = e.clientY;
                            }
                            
                            oX = cX - el.offsetLeft; 
                            oY = cY - el.offsetTop;
                            if (el.id === 'fun-stock-name-display' && stockNameFadeOutTimer) { 
                                clearTimeout(stockNameFadeOutTimer); 
                                stockNameFadeOutTimer = null; 
                            }
                            document.addEventListener('mousemove', mv, { passive: false });
                            document.addEventListener('touchmove', mv, { passive: false });
                            document.addEventListener('mouseup', stD, { once: true });
                            document.addEventListener('touchend', stD, { once: true });
                        };
                        
                        el.addEventListener('mousedown', sD_longPress);
                        el.addEventListener('touchstart', sD_longPress, { passive: false });
                        const lnk = el.querySelector('a'); 
                        if (lnk) { 
                            lnk.addEventListener('click', (e) => { if (hasMoved) e.preventDefault(); }); 
                        }
                        if(el.id === 'settings-btn') { 
                            el.addEventListener('click', (e) => { if (!hasMoved) { showWallpaperSettings(); settingsMenu.classList.add('visible'); } }); 
                            el.addEventListener('keydown', (e) => { if ((e.key === 'Enter' || e.key === ' ') && !hasMoved) { e.preventDefault(); showWallpaperSettings(); settingsMenu.classList.add('visible'); } });
                        }
                    };
                    
                    stockWidget.addEventListener('click', (e) => {
                        if (stockWidget.dataset.justDragged === 'true') return;
                        clearTimeout(stockWidgetClickTimer);
                        stockWidgetClickTimer = setTimeout(() => {
                            if (!getStockFlashState()) return;
                            const symbols = getStockSymbols();
                            if (symbols.length === 0) return;
                            const symbol = symbols[stockFlashIndex];
                            stockFlashIndex = (stockFlashIndex + 1) % symbols.length;
                            fetchQuoteNoKey(symbol)
                                .then(data => handleStockData(data, symbol))
                                .catch(err => console.error(`Stock Flash click trigger error for ${symbol}:`, err));
                        }, 200);
                    });
                    stockWidget.addEventListener('dblclick', (e) => {
                        clearTimeout(stockWidgetClickTimer);
                        stockSymbolsInput.value = getStockSymbols().join(', ');
                        stockFlashCheckbox.checked = getStockFlashState();
                        stockEditorMenu.classList.add('visible');
                    });
                    closeStockEditorBtn.addEventListener('click', () => stockEditorMenu.classList.remove('visible'));
                    stockEditorMenu.addEventListener('click', (e) => { if (e.target === stockEditorMenu) stockEditorMenu.classList.remove('visible'); });
                    saveStocksBtn.addEventListener('click', () => { 
                        const newSymbols = stockSymbolsInput.value.split(',').map(s => s.trim().toUpperCase()).filter(s => s.length > 0).slice(0, 7); 
                        saveStockSymbols(newSymbols); 
                        saveStockFlashState(stockFlashCheckbox.checked); 
                        stockFlashIndex = 0;
                        updateStockWidget(); 
                        stockEditorMenu.classList.remove('visible');
                    });

                    setInterval(updateTime, 1000); updateTime();
                    DRAGGABLE_ELEMENT_IDS.forEach(id => { const el = document.getElementById(id); if (el) makeDraggable(el); });
                    
                    loadPos();
                    fetchWeather(); setInterval(fetchWeather, 30 * 60 * 1000);
                    // Slower intervals to be polite to the proxy and avoid rate limiting
                    updateStockWidget(); setInterval(updateStockWidget, 5 * 60 * 1000);
                    checkStockFlashTrigger(); setInterval(checkStockFlashTrigger, 5 * 60 * 1000);
                })();
                
                function generateSquareArt(image, callback) {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const size = 512;
                    canvas.width = canvas.height = size;
                    const srcWidth = image.naturalWidth;
                    const srcHeight = image.naturalHeight;
                    const srcRatio = srcWidth / srcHeight;
                    let sx = 0, sy = 0, sWidth = srcWidth, sHeight = srcHeight;
                    if (srcRatio > 1) {
                        sWidth = srcHeight;
                        sx = (srcWidth - srcHeight) / 2;
                    } else {
                        sHeight = srcWidth;
                        sy = (srcHeight - srcWidth) / 2;
                    }
                    ctx.drawImage(image, sx, sy, sWidth, sHeight, 0, 0, size, size);
                    callback(canvas.toDataURL('image/jpeg'));
                }

                const getWps = () => JSON.parse(localStorage.getItem('lockscreenWallpapers_v2')) || [initialWallpaper];
                const saveWps = (wps) => localStorage.setItem('lockscreenWallpapers_v2', JSON.stringify(wps));
                const setWp = (wpObj) => {
                    exitPanningMode();
                    lockScreen.style.backgroundImage = `url('${wpObj.url}')`;
                    lockScreen.style.backgroundPosition = wpObj.position || 'center center';
                    wallpaperReady = false;
                    currentWallpaperImg.src = wpObj.url;
                    currentWallpaperImg.onload = () => {
                        wallpaperReady = true;
                        generateSquareArt(currentWallpaperImg, (artUrl) => {
                            window.radioPlayer.updateAlbumArt(artUrl);
                        });
                    };
                    currentWallpaperImg.onerror = () => {
                        wallpaperReady = false;
                        console.error("Failed to load wallpaper image for media art.");
                    };
                };

                const renderWpChoices = () => { const cont = document.getElementById('wallpaper-choices'); cont.innerHTML = ''; getWps().forEach(wp => { const thumb = document.createElement('div'); thumb.className = 'wallpaper-thumbnail'; thumb.style.backgroundImage = `url('${wp.url}')`; const rmvBtn = document.createElement('span'); rmvBtn.className = 'remove-thumb-btn'; rmvBtn.title = 'Remove wallpaper'; rmvBtn.addEventListener('click', (e) => { e.stopPropagation(); const newWps = getWps().filter(w => w.url !== wp.url); saveWps(newWps); renderWpChoices(); }); thumb.appendChild(rmvBtn); thumb.addEventListener('click', () => { setWp(wp); localStorage.setItem('lockscreenLastSelectedWp', wp.url); settingsMenu.classList.remove('visible'); }); cont.appendChild(thumb); }); };
                document.getElementById('wallpaper-url-input').addEventListener('keydown', (e) => { if (e.key === 'Enter') { const url = e.target.value.trim(); if(url.toLowerCase().endsWith('.gif')) { alert('Please use the GIF widget to add GIFs.'); e.target.value = ''; return; } if (url.match(/\.(jpeg|jpg|gif|png|webp)$/i)) { const wps = getWps(); if (!wps.some(w => w.url === url)) { const newWp = { url: url, position: 'center center' }; wps.push(newWp); saveWps(wps); setWp(newWp); localStorage.setItem('lockscreenLastSelectedWp', newWp.url); renderWpChoices(); } e.target.value = ''; settingsMenu.classList.remove('visible'); } else { alert('Invalid URL.'); } } });
                function exitPanningMode() { exitPanningModeCompletely(); }

                const resetInactivityPrompts = () => { clearTimeout(inactivityTimer); unlockPrompt.classList.remove('visible'); fullscreenHint.classList.remove('visible'); inactivityTimer = setTimeout(() => { if (document.fullscreenElement) { unlockPrompt.classList.add('visible'); } else { fullscreenHint.classList.add('visible'); } }, 60000); };
                ['mousemove', 'mousedown', 'keydown'].forEach(evt => document.addEventListener(evt, resetInactivityPrompts));
                resetInactivityPrompts();
                unlockPrompt.addEventListener('click', () => { if (document.fullscreenElement) document.exitFullscreen(); });
                
                lockScreen.addEventListener('dblclick', (e) => { 
                    if (e.target.closest('.draggable-item')) return; 
                    if (isPanningMode) {
                        exitPanningModeCompletely();
                        return;
                    }
                    if (!document.fullscreenElement) document.documentElement.requestFullscreen(); else document.exitFullscreen(); 
                });
                
                let isDraggingWp = false, sPanX, sPanY, sBgX, sBgY, startX, startY;
                let panModeTimeout = null;
                
                const panMove = (e) => { if (!isDraggingWp) return; hasMovedWp = true; e.preventDefault(); const cX = e.touches ? e.touches[0].clientX : e.clientX; const cY = e.touches ? e.touches[0].clientY : e.clientY; const dX = cX - sPanX, dY = cY - sPanY; let nBgX = sBgX + dX, nBgY = sBgY + dY; const sW = lockScreen.clientWidth, sH = lockScreen.clientHeight; const iW = currentWallpaperImg.naturalWidth, iH = currentWallpaperImg.naturalHeight; const sR = sW / sH, iR = iW / iH; let scW, scH; if (iR > sR) { scH = sH; scW = sH * iR; } else { scW = sW; scH = sW / iR; } const minX = sW - scW, minY = sH - scH; nBgX = Math.max(minX, Math.min(0, nBgX)); nBgY = Math.max(minY, Math.min(0, nBgY)); lockScreen.style.backgroundPosition = `${nBgX}px ${nBgY}px`; };
                
                const exitPanningModeCompletely = () => {
                    if (!isPanningMode) return;
                    isPanningMode = false;
                    isDraggingWp = false;
                    lockScreen.classList.remove('panning-active');
                    document.removeEventListener('mousemove', panMove); 
                    document.removeEventListener('touchmove', panMove);
                    clearTimeout(panModeTimeout);
                    const url = currentWallpaperImg.src;
                    const wps = getWps();
                    const idx = wps.findIndex(w => w.url === url);
                    if (idx > -1) {
                        wps[idx].position = lockScreen.style.backgroundPosition;
                        saveWps(wps);
                    }
                };
                
                const interactionEnd = () => { 
                    clearTimeout(pressHoldTimer); 
                    if (isPanningMode && isDraggingWp) { 
                        // Only stop dragging, but keep pan mode active for 3 seconds
                        isDraggingWp = false; 
                        document.removeEventListener('mousemove', panMove); 
                        document.removeEventListener('touchmove', panMove);
                        
                        // Save position after dragging ends
                        const url = currentWallpaperImg.src;
                        const wps = getWps();
                        const idx = wps.findIndex(w => w.url === url);
                        if (idx > -1) {
                            wps[idx].position = lockScreen.style.backgroundPosition;
                            saveWps(wps);
                        }
                        
                        // Keep pan mode active for 3 more seconds
                        clearTimeout(panModeTimeout);
                        panModeTimeout = setTimeout(exitPanningModeCompletely, 3000);
                    } 
                    document.removeEventListener('mouseup', interactionEnd); 
                    document.removeEventListener('touchend', interactionEnd); 
                    document.removeEventListener('mousemove', clearHoldTimer); 
                };
                const clearHoldTimer = () => { clearTimeout(pressHoldTimer); };
                const interactionStart = (e) => {
                    if (e.target.closest('.draggable-item')) return;
                    if (!wallpaperReady) return;
                    const sW = lockScreen.clientWidth, sH = lockScreen.clientHeight, iW = currentWallpaperImg.naturalWidth, iH = currentWallpaperImg.naturalHeight;
                    if (iW <= sW && iH <= sH && !isPanningMode) return;
                    hasMovedWp = false;
                    startX = e.touches ? e.touches[0].clientX : e.clientX;
                    startY = e.touches ? e.touches[0].clientY : e.clientY;
                    document.addEventListener('mouseup', interactionEnd);
                    document.addEventListener('touchend', interactionEnd);
                    clearTimeout(pressHoldTimer);
                    
                    // If already in pan mode, start dragging immediately
                    if (isPanningMode && !isDraggingWp) {
                        isDraggingWp = true;
                        const bgPos = window.getComputedStyle(lockScreen).backgroundPosition.split(' ');
                        sBgX = parseFloat(bgPos[0]);
                        sBgY = parseFloat(bgPos[1]);
                        sPanX = startX;
                        sPanY = startY;
                        document.addEventListener('mousemove', panMove);
                        document.addEventListener('touchmove', panMove);
                        clearTimeout(panModeTimeout); // Cancel auto-exit since user is actively panning
                        return;
                    }
                    
                    // Improved press and hold logic for better touchscreen experience
                    const isTouch = !!e.touches;
                    const holdDelay = isTouch ? 400 : 300; // Longer delay for touch devices
                    const moveThreshold = isTouch ? 25 : 15; // More forgiving movement threshold for touch
                    
                    pressHoldTimer = setTimeout(() => {
                        isPanningMode = true;
                        isDraggingWp = true;
                        lockScreen.classList.add('panning-active');
                        const bgPos = window.getComputedStyle(lockScreen).backgroundPosition.split(' ');
                        sBgX = parseFloat(bgPos[0]);
                        sBgY = parseFloat(bgPos[1]);
                        sPanX = startX;
                        sPanY = startY;
                        document.addEventListener('mousemove', panMove);
                        document.addEventListener('touchmove', panMove);
                        
                        // Visual feedback for successful pan mode activation
                        lockScreen.style.filter = 'brightness(1.1)';
                        setTimeout(() => lockScreen.style.filter = '', 150);
                        
                        // Set auto-exit timer for pan mode
                        clearTimeout(panModeTimeout);
                        panModeTimeout = setTimeout(exitPanningModeCompletely, 10000); // 10 seconds if no activity
                    }, holdDelay);
                    
                    const moveCheck = (ev) => {
                        const mX = ev.touches ? ev.touches[0].clientX : ev.clientX;
                        const mY = ev.touches ? ev.touches[0].clientY : ev.clientY;
                        if (Math.abs(mX - startX) > moveThreshold || Math.abs(mY - startY) > moveThreshold) {
                            clearTimeout(pressHoldTimer);
                            document.removeEventListener('mousemove', moveCheck);
                            document.removeEventListener('touchmove', moveCheck);
                        }
                    };
                    document.addEventListener('mousemove', moveCheck);
                    document.addEventListener('touchmove', moveCheck);
                };
                // Add touch double-tap to exit pan mode
                let wallpaperTapCount = 0;
                let wallpaperTapTimer = null;
                
                lockScreen.addEventListener('touchstart', (e) => {
                    if (e.target.closest('.draggable-item')) return;
                    if (isPanningMode && e.touches.length === 1) {
                        wallpaperTapCount++;
                        
                        if (wallpaperTapCount === 1) {
                            wallpaperTapTimer = setTimeout(() => {
                                wallpaperTapCount = 0;
                            }, 400);
                        } else if (wallpaperTapCount === 2) {
                            clearTimeout(wallpaperTapTimer);
                            wallpaperTapCount = 0;
                            e.preventDefault();
                            e.stopPropagation();
                            exitPanningModeCompletely();
                            return;
                        }
                    }
                    
                    // Call the normal interaction start
                    interactionStart(e);
                }, { passive: false });

                lockScreen.addEventListener('mousedown', interactionStart);
                
                const themeToggle = document.getElementById('theme-toggle');
                const clockColorInput = document.getElementById('clock-color-input');
                const fontSelect = document.getElementById('font-select');
                const resetPositionsBtn = document.getElementById('reset-positions-btn');

                const applyTheme = (theme) => lockScreen.classList.toggle('light-theme', theme === 'light');
                const applyClockColor = (color) => clock.style.color = color;
                const applyFont = (font) => clock.style.fontFamily = font;

                const savedTheme = localStorage.getItem('lockscreenTheme') || 'dark';
                themeToggle.checked = savedTheme === 'light';
                applyTheme(savedTheme);
                
                const savedColor = localStorage.getItem('lockscreenClockColor') || '#ffffff';
                clockColorInput.value = savedColor;
                applyClockColor(savedColor);

                const savedFont = localStorage.getItem('lockscreenClockFont') || "'Oswald', sans-serif";
                fontSelect.value = savedFont;
                applyFont(savedFont);

                themeToggle.addEventListener('change', () => { const newTheme = themeToggle.checked ? 'light' : 'dark'; localStorage.setItem('lockscreenTheme', newTheme); applyTheme(newTheme); });
                clockColorInput.addEventListener('input', () => { const newColor = clockColorInput.value; localStorage.setItem('lockscreenClockColor', newColor); applyClockColor(newColor); });
                fontSelect.addEventListener('change', () => { const newFont = fontSelect.value; localStorage.setItem('lockscreenClockFont', newFont); applyFont(newFont); });

                resetPositionsBtn.addEventListener('click', () => {
                    localStorage.removeItem('lockscreenItemPositions_v5');
                    localStorage.removeItem('lockscreenNoteContent');
                    localStorage.removeItem('lockscreenNoteFontFamily');
                    localStorage.removeItem('lockscreenNoteFontSize');
                    localStorage.removeItem('lockscreenGifUrls_v2');
                    localStorage.removeItem('lockscreenLastGif');
                    localStorage.removeItem('webcamFullState');
                    localStorage.removeItem('webcamPanZoomState');
                    window.radioPlayer.reset();
                    window.webcamPlayer.stop();
                    document.getElementById('gif-display').src = '';
                    ['clock', 'youtube-music-btn', 'youtube-btn', 'stock-widget', 'settings-btn', 'fun-stock-name-display', 'note-widget', 'music-widget', 'music-visualizer-widget', 'gif-widget', 'webcam-widget', 'webcam-toggle-btn'].forEach(id => {
                        const el = document.getElementById(id);
                        if (el) el.style.cssText = '';
                    });
                    // Use existing applyClockScale
                    applyClockScale(1);
                    settingsMenu.classList.remove('visible');
                });

                window.startPolling = (session, type = 'wallpaper') => {
                    if (pollingInterval) clearInterval(pollingInterval);
                    const uploadUrl = `${window.location.href.split('?')[0]}?upload=true&session=${session}`;
                    const qrCodeContainer = document.getElementById('qr-code');
                    qrCodeContainer.innerHTML = '';
                    qrModal.style.display = 'flex';
                    new QRCode(qrCodeContainer, { text: uploadUrl, width: 200, height: 200 });

                    pollingInterval = setInterval(() => {
                        fetch(`https://api.npoint.io/${NPOINT_BIN_ID}`, { cache: 'no-cache' })
                            .then(r => r.json())
                            .then(data => {
                                if (data && data[session]) {
                                    clearInterval(pollingInterval);
                                    pollingInterval = null;
                                    qrModal.style.display = 'none';
                                    const newUrl = data[session];

                                    if (type === 'gif') {
                                        window.addGif(newUrl);
                                    } else {
                                        const newWp = { url: newUrl, position: 'center center' };
                                        const wps = getWps();
                                        if (!wps.some(w => w.url === newWp.url)) { wps.push(newWp); saveWps(wps); }
                                        setWp(newWp); localStorage.setItem('lockscreenLastSelectedWp', newWp.url); renderWpChoices();
                                    }
                                }
                            }).catch(err => { console.log("Polling... waiting for data."); });
                    }, 2500);
                }

                document.getElementById('qr-upload-btn').addEventListener('click', () => window.startPolling(`wallpaper_session_${Date.now()}`, 'wallpaper'));
                qrModal.addEventListener('click', (e) => { if (e.target === qrModal) { qrModal.style.display = 'none'; clearInterval(pollingInterval); } });
                
                renderWpChoices();
                const allWps = getWps();
                const lastSelectedUrl = localStorage.getItem('lockscreenLastSelectedWp');
                let wpToLoad = allWps.find(w => w.url === lastSelectedUrl);
                if (!wpToLoad) {
                    wpToLoad = allWps[0] || initialWallpaper;
                }
                setWp(wpToLoad);

                document.addEventListener('keydown', (e) => {
                    if (document.getElementById('note-widget').classList.contains('edit-mode')) {
                        if (e.key === 'Escape') {
                            document.getElementById('note-widget').querySelector('#note-textarea').blur();
                            exitNoteEditMode();
                        }
                        return;
                    }
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') return;
                    if (!getStockFlashState()) return;
                    
                    let isUp = null;
                    if (e.key === 'ArrowUp') isUp = true;
                    if (e.key === 'ArrowDown') isUp = false;
                    
                    if (isUp !== null) {
                        e.preventDefault();
                        const symbols = getStockSymbols();
                        if (symbols.length === 0) return;
                        const symbol = symbols[stockFlashIndex];
                        const isSuper = e.shiftKey;
                        triggerStockFlashEffect(isUp, isSuper, symbol);
                    }
                });
            }
        });
    </script>
</body>
</html>
